{"version":3,"file":"provenance-tree-visualization.es5.js","sources":["../src/gratzl.ts","../src/aggregation/aggregation-implementations.ts","../src/aggregation/aggregation-objects.ts","../src/components.ts","../src/aggregation/aggregation.ts","../src/gratzl_old.ts","../src/caterpillar.ts","../src/provenance-tree-visualization.ts"],"sourcesContent":["import { HierarchyNode, HierarchyPointNode } from \"d3-hierarchy\";\n\nfunction depthSort(\n  a: IHierarchyPointNodeWithMaxDepth<any>,\n  b: IHierarchyPointNodeWithMaxDepth<any>\n) {\n  if (a.maxDescendantDepth > b.maxDescendantDepth) {\n    return -1;\n  } else if (a.maxDescendantDepth < b.maxDescendantDepth) {\n    return 1;\n  }\n  return 0;\n}\n\nexport interface IGratzlLayout<Datum> {\n  (\n    root: HierarchyNode<Datum>,\n    activeNode: HierarchyNode<Datum>\n  ): IHierarchyPointNodeWithMaxDepth<Datum>;\n  size(): [number, number];\n  size(size: [number, number]): this;\n}\n\nexport interface IHierarchyPointNodeWithMaxDepth<T>\n  extends HierarchyPointNode<T> {\n  maxDescendantDepth: number;\n  // xOffset: number;\n  // x, y, links()\n}\n\nexport default function GratzlLayout<T>(\n  _root: HierarchyNode<T>,\n  _current: HierarchyNode<T>\n): IHierarchyPointNodeWithMaxDepth<T> {\n  const root = _root as IHierarchyPointNodeWithMaxDepth<T>;\n  const current = _current as IHierarchyPointNodeWithMaxDepth<T>;\n  const widths: number[] = [];\n  // const maxY = Math.max.apply(null, root.leaves().map((leaf) => leaf.depth));\n\n  function setTreeX(node: IHierarchyPointNodeWithMaxDepth<T>, val: number) {\n    node.x = val;\n    node.y = node.depth;\n    widths[node.depth] = val;\n    if (node.children) {\n      node\n        .leaves()\n        .sort(depthSort)\n        .forEach(leaf => {\n          if (typeof leaf.x === \"undefined\") {\n            const width = Math.max.apply(\n              null,\n              widths.slice(node.depth, leaf.depth + 1)\n            );\n            setTreeX(leaf, val > width ? val : width + 1);\n          }\n        });\n    }\n\n    if (node.parent && typeof node.parent.x === \"undefined\") {\n      setTreeX(node.parent, val);\n    }\n  }\n\n  root.leaves().forEach(leaf => {\n    leaf.ancestors().forEach(leafAncestor => {\n      if (\n        !leafAncestor.maxDescendantDepth ||\n        leaf.depth > leafAncestor.maxDescendantDepth\n      ) {\n        leafAncestor.maxDescendantDepth = leaf.depth;\n      }\n    });\n  });\n\n  /* start at the deepest leaf of activeNode. */\n  let deepestLeaf = current;\n  deepestLeaf.leaves().forEach(leaf => {\n    if (deepestLeaf.depth < leaf.depth) {\n      deepestLeaf = leaf;\n    }\n  });\n\n  setTreeX(deepestLeaf, 0);\n\n  //\n  // const maxX = Math.max.apply(null, widths);\n  // const maxY = Math.max.apply(null, root.leaves().map((leaf) => leaf.depth));\n  // root.each((node) => {\n  //   sizeNode(node, maxX, maxY);\n  // });\n\n  return root;\n\n  //\n  // const tree: IGratzlLayout<Datum> = Object.assign(\n  //   (_root: HierarchyNode<Datum>, _activeNode: HierarchyNode<Datum>) => {\n  //     /*\n  //   * set maxDescendantDepth on each node,\n  //   * which is the depth of its deepest child\n  //   *\n  //   * */\n  //\n  //     const root = _root as IHierarchyPointNodeWithMaxDepth<Datum>;\n  //     const activeNode = _activeNode as IHierarchyPointNodeWithMaxDepth<Datum>;\n  //\n  //     root.leaves().forEach((leaf) => {\n  //       leaf.ancestors().forEach((leafAncestor) => {\n  //         if (\n  //           !leafAncestor.maxDescendantDepth ||\n  //           leaf.depth > leafAncestor.maxDescendantDepth\n  //         ) {\n  //           leafAncestor.maxDescendantDepth = leaf.depth;\n  //         }\n  //       });\n  //     });\n  //\n  //     /* rendering should start at the deepest leaf of activeNode. */\n  //     let deepestLeaf = activeNode;\n  //     activeNode.leaves().forEach((leaf) => {\n  //       if (deepestLeaf.depth < leaf.depth) {\n  //         deepestLeaf = leaf;\n  //       }\n  //     });\n  //\n  //     setTreeX(deepestLeaf, 0);\n  //\n  //     const maxX = Math.max.apply(null, widths);\n  //     const maxY = Math.max.apply(null, root.leaves().map((leaf) => leaf.depth));\n  //     root.each((node) => {\n  //       sizeNode(node, maxX, maxY);\n  //     });\n  //\n  //     return root;\n  //   },\n  //   {\n  //     size: ((x: [number, number] | undefined) => {\n  //       return x ? ((dx = +x[0]), (dy = +x[1]), tree) : [dx, dy];\n  //     }) as any,\n  //   },\n  // );\n  //\n  // function sizeNode(\n  //   node: IHierarchyPointNodeWithMaxDepth<any>,\n  //   maxX: number,\n  //   maxY: number,\n  // ): void {\n  //   node.x = maxX === 0 ? dx : dx - (dx / maxX) * node.xOffset;\n  //   node.y = maxY === 0 ? dy : (dy / maxY) * node.depth;\n  // }\n\n  // return tree;\n}\n","import { IGroupedTreeNode } from \"../utils\";\nimport {\n  ProvenanceNode,\n  isStateNode\n} from \"@visualstorytelling/provenance-core\";\n\n/**\n * @description Type for the tests for aggregating data.\n * @param a {IGroupedTreeNode<ProvenanceNode>} -\n * @param b {IGroupedTreeNode<ProvenanceNode>} -\n * @returns Returns true if the nodes has passed the test.\n */\nexport type NodeGroupTest<T> = (\n  a: IGroupedTreeNode<T>,\n  b: IGroupedTreeNode<T>\n) => boolean;\n\n/**\n * @description Type for the data aggregation algorithms\n * @param currentNode {IGroupedTreeNode<ProvenanceNode>} - Selected node.\n * @param node {IGroupedTreeNode<ProvenanceNode>} - Root of the tree.\n * @param test {NodeGroupTest<ProvenanceNode>} - Test to be executed.\n * @param mainBranch {Array<String>} - List of node's id which belong to the master branch.\n * @param par {any} - Optional parameter required for the algorithm\n */\nexport type NodeAggregationAlgorithm = (\n  currentNode: IGroupedTreeNode<ProvenanceNode>,\n  node: IGroupedTreeNode<ProvenanceNode>,\n  tests: NodeGroupTest<ProvenanceNode>[],\n  mainBranch?: Array<string>,\n  par?: any\n) => void;\n\n/**\n * @description Interface defines aggregation strategy.\n * @param name {string} - Name of the procedure\n * @param test {NodeGroupTest<ProvenanceNode>} - Test to be executed;\n * @param algorithm {NodeAggregationAlgorithm} - Algorithm to be performed;\n * @param arg {any} - Optional parameter if needed.\n * @param description {String} - Description of the procedure.\n */\nexport interface NodeAggregator<T> {\n  name: string;\n  tests: NodeGroupTest<T>[];\n  algorithm: NodeAggregationAlgorithm;\n  arg?: any;\n  description?: String;\n}\n\n/**\n * @description Child removed, child's children go to the parent.\n * @param node {IGroupedTreeNode<ProvenanceNode>} - Parent node\n * @param child {IGroupedTreeNode<ProvenanceNode>} - Child node\n */\nfunction transferToParent(\n  node: IGroupedTreeNode<ProvenanceNode>,\n  child: IGroupedTreeNode<ProvenanceNode>\n) {\n  node.children.splice(node.children.indexOf(child), 1);\n  node.children.push(...child.children);\n  node.wrappedNodes.push(...child.wrappedNodes);\n}\n\n/**\n * @description Child removed, child's children go to grandChild. GrandChild becomes node's child.\n * @param node {IGroupedTreeNode<ProvenanceNode>} - Parent node\n * @param child {IGroupedTreeNode<ProvenanceNode>} - Child node\n * @param grandChild {IGroupedTreeNode<ProvenanceNode>} - Child of the child node\n */\nfunction transferChildren(\n  node: IGroupedTreeNode<ProvenanceNode>,\n  child: IGroupedTreeNode<ProvenanceNode>,\n  grandChild: IGroupedTreeNode<ProvenanceNode>\n) {\n  node.children.splice(node.children.indexOf(child), 1);\n  child.children.splice(child.children.indexOf(grandChild), 1);\n  grandChild.wrappedNodes.push(...child.wrappedNodes);\n  grandChild.children.push(...child.children);\n  node.children.push(grandChild);\n}\n\n/**\n * @description Pointed node wraps ALL children recursively\n * @param node {IGroupedTreeNode<ProvenanceNode>} - Selected node\n */\nexport function transferAll(node: IGroupedTreeNode<ProvenanceNode>) {\n  let done: boolean;\n  do {\n    done = false;\n    if (node.children) {\n      for (const child of node.children) {\n        transferToParent(node, child);\n        done = true;\n      }\n    }\n  } while (done);\n}\n\n/**\n * @description Test whether a node should be constrained based on the currently selected node.\n * @param  node  {IGroupedTreeNode<ProvenanceNode>} - The node to test.\n * @param  node  {IGroupedTreeNode<ProvenanceNode>} - Currently selected node.\n */\nexport function shouldConstrain(\n  node: IGroupedTreeNode<ProvenanceNode>,\n  selectedNode: IGroupedTreeNode<ProvenanceNode>\n): boolean {\n  let result = false;\n  const rawNode = node.wrappedNodes[0];\n\n  if (node === selectedNode || rawNode.metadata.bookmarked) {\n    result = true;\n  } else if (node.children.includes(selectedNode)) {\n    result = true;\n  } else if (selectedNode.children.includes(node)) {\n    result = true;\n  }\n\n  return result;\n}\n\n/**\n * @description Test whether a node is a leaf node.\n * @param  node  {IGroupedTreeNode<ProvenanceNode>} - The node to test.\n */\nexport function isLeafNode(node: IGroupedTreeNode<ProvenanceNode>): boolean {\n  let result = false;\n\n  if (node.children.length === 0) {\n    result = true;\n  }\n\n  return result;\n}\n\n/**\n * @description Test whether a node is an interval node.\n * @param  node  {IGroupedTreeNode<ProvenanceNode>} - The node to test.\n */\nexport function isIntervalNode(\n  node: IGroupedTreeNode<ProvenanceNode>\n): boolean {\n  let result = false;\n\n  if (node.children.length === 1) {\n    result = true;\n  }\n\n  return result;\n}\n\n/**\n * @description Test whether two nodes are neighbours.\n * @param  a  {IGroupedTreeNode<ProvenanceNode>} - The first node to test.\n * @param  b  {IGroupedTreeNode<ProvenanceNode>} - The second node to test.\n */\nexport function areNeighbours(\n  a: IGroupedTreeNode<ProvenanceNode>,\n  b: IGroupedTreeNode<ProvenanceNode>\n): boolean {\n  let result = false;\n\n  if (b.children.includes(a)) {\n    result = true;\n  } else if (a.children.includes(b)) {\n    result = true;\n  }\n\n  return result;\n}\n\n/**\n * @description Calculate the distance of this node to any node in the main (selected) branch.\n * @param  node  {IGroupedTreeNode<ProvenanceNode>} - The node to test.\n * @param  mainBranch  {Array<string>} - List of node ids which belong to the master branch.\n */\nexport function distanceToMainBranch(\n  node: ProvenanceNode,\n  mainBranch: Array<string> | undefined\n): number {\n  let result = 0;\n\n  if (mainBranch === undefined) {\n    result = 0;\n  } else if (isStateNode(node) && mainBranch.includes(node.id)) {\n    result = 0;\n  } else {\n    if (isStateNode(node)) {\n      result = 1 + distanceToMainBranch(node.parent, mainBranch);\n    }\n  }\n\n  return result;\n}\n\n/**\n * @description Returns the minimum depth possible from the node selected.\n * @param node {IGroupedTreeNode<ProvenanceNode>} - Selected node\n * @returns Number of nodes you have to cross to go to the deepest leaf from the node selected.\n */\nexport const minDepth = <T>(node: IGroupedTreeNode<T>): number => {\n  if (node.children.length === 0) {\n    return 0;\n  }\n  return Math.min(...node.children.map(minDepth)) + 1;\n};\n\n/**\n * @description Returns the maximum depth possible from the node selected.\n * @param node {IGroupedTreeNode<ProvenanceNode>} - Selected node\n * @returns Number of nodes you have to cross to go to the deepest leaf from the node selected.\n */\nexport const maxDepth = <T>(node: IGroupedTreeNode<T>): number => {\n  if (node.children.length === 0) {\n    return 1;\n  }\n  return Math.max(...node.children.map(maxDepth)) + 1;\n};\n\n/**\n * @description Returns the distance to the subroot from the node selected.\n * @param provNode {ProvenanceNode} - Selected node\n * @returns Number of nodes you have to cross to go to the subroot up from the node selected.\n */\nexport const subrootDist = (provNode: ProvenanceNode): number => {\n  let value = 0;\n\n  if (!isStateNode(provNode)) {\n    value = 0;\n  } else if (isStateNode(provNode)) {\n    if (provNode.parent.children.length > 1) {\n      value = 1;\n    } else {\n      value = 1 + subrootDist(provNode.parent);\n    }\n  }\n  return value;\n};\n\n/**\n * @description Returns the number of conexions with the node selected.\n * @param node {IGroupedTreeNode<ProvenanceNode>} - Selected node\n * @returns Number of nodes you have to cross to go to the deepest leaf from the node selected.\n */\nexport const connectivity = (node: IGroupedTreeNode<ProvenanceNode>) => {\n  return 1 + node.children.length;\n};\n\n/**\n * @description Return the first node found in nodes that also belongs to the main branch of the tree.\n * @param  mainBranch  {Array<string>} - List of node ids which belong to the master branch.\n * @param  nodes  {Array<IGroupedTreeNode<ProvenanceNode>>} - List of nodes to test.\n */\nconst mainNode = (\n  mainBranch: Array<string>,\n  nodes: Array<IGroupedTreeNode<ProvenanceNode>>\n): IGroupedTreeNode<ProvenanceNode> | undefined => {\n  let mNode;\n  for (const node of nodes) {\n    if (mainBranch.includes(node.wrappedNodes[0].id)) {\n      mNode = node;\n      break;\n    }\n  }\n  return mNode;\n};\n\n/**\n * @description Compare the depth of two selected nodes.\n * @param  node1  {IGroupedTreeNode<ProvenanceNode>} - Selected node #1\n * @param  node2  {IGroupedTreeNode<ProvenanceNode>} - Selected node #2\n */\nconst nodeDepthComparison = <T>(\n  node1: IGroupedTreeNode<T>,\n  node2: IGroupedTreeNode<T>\n): number => {\n  if (maxDepth(node1) > maxDepth(node2)) {\n    return 1;\n  } else if (maxDepth(node1) < maxDepth(node2)) {\n    return -1;\n  }\n  return 0;\n};\n\n/**\n * @description Test everything.\n * @param tests {Array<NodeGroupTest<ProvenanceNode>>} - The tests to run\n * @param  node1  {IGroupedTreeNode<ProvenanceNode>} - Selected node #1\n * @param  node2  {IGroupedTreeNode<ProvenanceNode>} - Selected node #2\n * @returns true only if all tests return true\n */\nconst testAll = (\n  tests: Array<NodeGroupTest<ProvenanceNode>>,\n  node1: IGroupedTreeNode<ProvenanceNode>,\n  node2: IGroupedTreeNode<ProvenanceNode>\n): boolean => {\n  let result = true;\n\n  for (const test of tests) {\n    result = test(node1, node2);\n    if (!result) {\n      break;\n    }\n  }\n\n  return result;\n};\n\n// /**\n//  * @description Constrain neighbours\n//  * @param node {IGroupedTreeNode<ProvenanceNode>} - Node\n//  * @param selectedNode {IGroupedTreeNode<ProvenanceNode>} - Selected node\n//  */\n// export const neighbours = (node: IGroupedTreeNode<ProvenanceNode>, selectedNode: IGroupedTreeNode<ProvenanceNode>) => {\n//   let neighbour = false;\n\n//   if (node === selectedNode || selectedNode.children.includes(node) || node.children.includes(selectedNode)) {\n//     neighbour = true;\n//   }\n\n//   node.neighbour = neighbour;\n\n//   for (const child of node.children) {\n//     neighbours(child, selectedNode);\n//   }\n// };\n\n/////////////////// DIFFERENT DATA AGGREGATION ALGORITHM ///////////\n/**\n * @description No algorithm is applied. Created for a better understanding.\n * @param  node  {IGroupedTreeNode<ProvenanceNode>} - Root of the graph\n * @param  tests  {Array<NodeGroupTest<ProvenanceNode>>} - Test to be checked during execution.\n * @param  currentNode  {IGroupedTreeNode<ProvenanceNode>} -\n */\nexport const doNothing: NodeAggregationAlgorithm = (\n  currentNode: IGroupedTreeNode<ProvenanceNode>,\n  node: IGroupedTreeNode<ProvenanceNode>,\n  tests: NodeGroupTest<ProvenanceNode>[]\n) => { };\n\n/**\n * @param  node  {IGroupedTreeNode<ProvenanceNode>} - Root of the graph\n * @param  tests  {Array<NodeGroupTest<ProvenanceNode>>} - Tests to be checked during execution.\n */\nexport const group: NodeAggregationAlgorithm = (\n  currentNode: IGroupedTreeNode<ProvenanceNode>,\n  node: IGroupedTreeNode<ProvenanceNode>,\n  tests: NodeGroupTest<ProvenanceNode>[]\n) => {\n  let merged = false;\n  do {\n    merged = false;\n    for (const child of node.children) {\n      if (!shouldConstrain(child, currentNode)) {\n        for (const grandChild of child.children) {\n          if (testAll(tests, child, grandChild)) {\n            transferChildren(node, child, grandChild);\n            merged = true;\n            break;\n          }\n        }\n        if (merged) {\n          break;\n        }\n      }\n    }\n  } while (merged);\n  node.children.map(child => group(currentNode, child, tests));\n};\n\n/**\n * @param  node  {IGroupedTreeNode<ProvenanceNode>} - Root of the graph\n * @param  tests  {Array<NodeGroupTest<ProvenanceNode>>} - Tests to be checked during execution.\n */\nexport const compress: NodeAggregationAlgorithm = (\n  currentNode: IGroupedTreeNode<ProvenanceNode>,\n  node: IGroupedTreeNode<ProvenanceNode>,\n  tests: NodeGroupTest<ProvenanceNode>[]\n) => {\n  let merged = false;\n  do {\n    merged = false;\n    for (const child of node.children) {\n      if (!shouldConstrain(child, currentNode)) {\n        if (testAll(tests, node, child)) {\n          transferToParent(node, child);\n          merged = true;\n          break;\n        }\n      }\n    }\n  } while (merged);\n  node.children.map(child => compress(currentNode, child, tests));\n};\n\n/**\n * @param  node  {IGroupedTreeNode<ProvenanceNode>} - Root of the graph\n * @param  tests  {Array<NodeGroupTest<ProvenanceNode>>} - Tests to be checked during execution.\n * @param mainBranch {Array<string>} - List of node's id which belong to the master branch.\n * @param arg {any} - Optinal parameter\n */\nexport const prune: NodeAggregationAlgorithm = (\n  currentNode: IGroupedTreeNode<ProvenanceNode>,\n  node: IGroupedTreeNode<ProvenanceNode>,\n  tests: NodeGroupTest<ProvenanceNode>[],\n  mainBranch: Array<string> | undefined,\n  arg: any\n) => {\n  const parameter: number = +arg;\n  let merged = false;\n\n  do {\n    merged = false;\n    const p = arg;\n\n    for (const child of node.children) {\n      if (!shouldConstrain(child, currentNode)) {\n        const dist = distanceToMainBranch(child.wrappedNodes[0], mainBranch);\n        if (isLeafNode(child)) {\n          if (dist <= p) {\n            transferToParent(node, child);\n            merged = true;\n          }\n        } else {\n          for (const grandChild of child.children) {\n            if (\n              !shouldConstrain(grandChild, currentNode) &&\n              distanceToMainBranch(child.wrappedNodes[0], mainBranch) > 0\n            ) {\n              const childDepth = maxDepth(child);\n              if (dist + childDepth <= p) {\n                transferChildren(node, child, grandChild);\n                merged = true;\n              }\n            }\n          }\n        }\n      }\n    }\n  } while (merged);\n  node.children.map(child =>\n    prune(currentNode, child, tests, mainBranch, parameter)\n  );\n};\n\n/**\n * @param  node  {IGroupedTreeNode<ProvenanceNode>} - Root of the graph\n * @param  tests  {Array<NodeGroupTest<ProvenanceNode>>} - Test to be checked during execution.\n * @param arg {any} - Optinal parameter\n */\nexport const plotTrimmerFunc: NodeAggregationAlgorithm = (\n  currentNode: IGroupedTreeNode<ProvenanceNode>,\n  node: IGroupedTreeNode<ProvenanceNode>,\n  tests: NodeGroupTest<ProvenanceNode>[],\n  mainBranch: Array<string> | undefined,\n  arg: any\n) => {\n  trimmer(currentNode, node, tests, mainBranch, arg);\n};\n\nexport const trimmerAssignValues = (node: IGroupedTreeNode<ProvenanceNode>) => {\n  // Leaf value = subroot distance * 2\n  // Interval nodes value = 1\n  // Subroots value = Minimum subroot distance of children * 2 + 1\n  let value = 0;\n\n  if (!isStateNode(node.wrappedNodes[0]) === null) {\n    value = Number.MAX_VALUE;\n  } else if (connectivity(node) === 1) {\n    // Leaf node\n    value = subrootDist(node.wrappedNodes[0]) * 2;\n  } else if (connectivity(node) === 2) {\n    // Interval node\n    value = 1;\n  } else {\n    // Subroot\n    value = minDepth(node) * 2 + 1;\n  }\n\n  node.plotTrimmerValue = value;\n\n  for (const child of node.children) {\n    trimmerAssignValues(child);\n  }\n};\n\n/**\n * @param  node  {IGroupedTreeNode<ProvenanceNode>} - Root of the graph\n * @param  tests  {Array<NodeGroupTest<ProvenanceNode>>} - Test to be checked during execution.\n * @param arg {any} - Optinal parameter\n */\nconst trimmer: NodeAggregationAlgorithm = (\n  currentNode: IGroupedTreeNode<ProvenanceNode>,\n  node: IGroupedTreeNode<ProvenanceNode>,\n  tests: NodeGroupTest<ProvenanceNode>[],\n  mainBranch: Array<string> | undefined,\n  arg: any\n) => {\n  const parameter: number = +arg;\n  let merged: boolean;\n\n  trimmerAssignValues(node);\n\n  do {\n    merged = false;\n\n    for (const child of node.children) {\n      if (!shouldConstrain(child, currentNode)) {\n        if (parameter >= child.plotTrimmerValue) {\n          transferToParent(node, child);\n          merged = true;\n        }\n      }\n    }\n  } while (merged);\n  node.children.map(child =>\n    trimmer(currentNode, child, tests, mainBranch, parameter)\n  );\n};\n\n/**\n * @param  node  {IGroupedTreeNode<ProvenanceNode>} - Root of the graph\n * @param  test  {IGroupedTreeNode<ProvenanceNode>} - Test to be checked during execution.\n * @param arg {any} - Optinal parameter\n */\nexport const plotTrimmerFuncG: NodeAggregationAlgorithm = (\n  currentNode: IGroupedTreeNode<ProvenanceNode>,\n  node: IGroupedTreeNode<ProvenanceNode>,\n  tests: NodeGroupTest<ProvenanceNode>[],\n  mainBranch: Array<string> | undefined,\n  arg: any\n) => {\n  const parameter = +arg;\n  let prunePar = 0;\n\n  for (let i = 0; i <= parameter; i++) {\n    if (i % 2 === 0 && i !== 0) {\n      prunePar = prunePar + 1;\n      prune(currentNode, node, tests, mainBranch, prunePar);\n    } else {\n      group(currentNode, node, tests);\n    }\n  }\n};\n\n/**\n * @param  node  {IGroupedTreeNode<ProvenanceNode>} - Root of the graph\n * @param  test  {IGroupedTreeNode<ProvenanceNode>} - Test to be checked during execution.\n * @param arg {any} - Optinal parameter\n */\nexport const plotTrimmerFuncC: NodeAggregationAlgorithm = (\n  currentNode: IGroupedTreeNode<ProvenanceNode>,\n  node: IGroupedTreeNode<ProvenanceNode>,\n  tests: NodeGroupTest<ProvenanceNode>[],\n  mainBranch: Array<string> | undefined,\n  arg: any\n) => {\n  const parameter = +arg;\n  let prunePar = 0;\n\n  for (let i = 0; i <= parameter; i++) {\n    if (i % 2 === 0 && i !== 0) {\n      prunePar = prunePar + 1;\n      prune(currentNode, node, tests, mainBranch, prunePar);\n    } else {\n      compress(currentNode, node, tests);\n    }\n  }\n};\n","import {\n  compress,\n  NodeAggregator,\n  doNothing,\n  group,\n  NodeGroupTest,\n  plotTrimmerFunc,\n  prune,\n  areNeighbours,\n  plotTrimmerFuncC,\n  plotTrimmerFuncG\n} from \"./aggregation-implementations\";\nimport {\n  ProvenanceNode,\n  isStateNode\n} from \"@visualstorytelling/provenance-core\";\nimport { IGroupedTreeNode } from \"../utils\";\n\n/**\n * @description Getter for the user intent of the node selected.\n * @param  node  {IGroupedTreeNode<ProvenanceNode>} - Node selected.\n * @returns Returns the Intent of the user for the node selected.\n */\nexport function getNodeIntent(node: ProvenanceNode): string {\n  if (\n    isStateNode(node) &&\n    node.action &&\n    node.action.metadata &&\n    node.action.metadata.userIntent\n  ) {\n    return node.action.metadata.userIntent;\n  }\n  return \"none\";\n}\n\nexport function getNodeRenderer(node: ProvenanceNode): string {\n  if (\n    isStateNode(node) &&\n    node.action &&\n    node.action.metadata &&\n    node.action.metadata.renderer\n  ) {\n    return node.action.metadata.renderer;\n  }\n  return \"none\";\n}\n\n/**\n * @description Test whether a node is a key node or not.\n * @param  node  {IGroupedTreeNode<ProvenanceNode>} - Node selected.\n */\nexport function isKeyNode(node: ProvenanceNode): boolean {\n  if (\n    !isStateNode(node) ||\n    node.children.length === 0 ||\n    node.children.length > 1 ||\n    node.parent.children.length > 1 ||\n    (node.children.length === 1 &&\n      getNodeIntent(node) !== getNodeIntent(node.children[0]))\n  ) {\n    return true;\n  }\n  return false;\n}\n\n/**\n * @description Returns a label for grouped nodes.\n * @param  node  {IGroupedTreeNode<ProvenanceNode>} - Node selected.\n */\nexport const groupNodeLabel = (node: IGroupedTreeNode<ProvenanceNode>) => {\n  if (node.wrappedNodes.length === 1) {\n    return node.wrappedNodes[0].label;\n  } else {\n    return node.wrappedNodes[0].label;\n  }\n};\n\n/**\n * @description Wraps a node and its children recursively\n * in an extra IGroupedTreeNode; which can be manipulated for grouping etc,\n * without modifying the (provenance) node.\n * @param  node  {IGroupedTreeNode<ProvenanceNode>} - Node selected.\n */\nexport const wrapNode = (\n  node: ProvenanceNode\n): IGroupedTreeNode<ProvenanceNode> => {\n  return {\n    wrappedNodes: [node],\n    children: node.children.map(wrapNode),\n    plotTrimmerValue: -1,\n    neighbour: false,\n    bookmarked: false\n  };\n};\n\n/**\n * @description Test placeholder.\n * @param a {IGroupedTreeNode<ProvenanceNode>} - Node #1 to be tested.\n * @param b {IGroupedTreeNode<ProvenanceNode>} - Node #2 to be tested.\n */\nexport const testNothing: NodeGroupTest<ProvenanceNode> = (\n  a: IGroupedTreeNode<ProvenanceNode>,\n  b: IGroupedTreeNode<ProvenanceNode>\n) => false;\n\n/**\n * @description Test if two nodes share the same userIntent.\n * @param a {IGroupedTreeNode<ProvenanceNode>} - Node #1 to be tested.\n * @param b {IGroupedTreeNode<ProvenanceNode>} - Node #2 to be tested.\n */\nexport const testUserIntent: NodeGroupTest<ProvenanceNode> = (\n  a: IGroupedTreeNode<ProvenanceNode>,\n  b: IGroupedTreeNode<ProvenanceNode>\n) => getNodeIntent(a.wrappedNodes[0]) === getNodeIntent(b.wrappedNodes[0]);\n\n/**\n * @description Test if b is an interval node.\n * @param a {IGroupedTreeNode<ProvenanceNode>} - Not used.\n * @param b {IGroupedTreeNode<ProvenanceNode>} - Node to be tested.\n */\nexport const testIsIntervalNode: NodeGroupTest<ProvenanceNode> = (\n  a: IGroupedTreeNode<ProvenanceNode>,\n  b: IGroupedTreeNode<ProvenanceNode>\n) => b.children.length === 1;\n\n/**\n * @description Test if a and b are neighbours.\n * @param a {IGroupedTreeNode<ProvenanceNode>} - Node #1 to be tested.\n * @param b {IGroupedTreeNode<ProvenanceNode>} - Node #2 to be tested.\n */\nexport const testNeighbours: NodeGroupTest<ProvenanceNode> = (\n  a: IGroupedTreeNode<ProvenanceNode>,\n  b: IGroupedTreeNode<ProvenanceNode>\n) => areNeighbours(a, b);\n\n//////// Objects that represent the different data aggregation algorithms///////////\n\n/**Default Option as Raw Data */\nexport const defaultData: NodeAggregator<ProvenanceNode> = {\n  name: \"Select Aggregation\",\n  tests: [testNothing],\n  algorithm: doNothing,\n  arg: false,\n  description: \"No algorithm is applied. The full provenance data is shown.\"\n};\n/**\n * @description Object of the interface DataAggregation<ProvenanceNode>.\n */\nexport const rawData: NodeAggregator<ProvenanceNode> = {\n  name: \"Raw data\",\n  tests: [testNothing],\n  algorithm: doNothing,\n  arg: false,\n  description: \"No algorithm is applied. The full provenance data is shown.\"\n};\n\n/**\n * @description Object of the interface DataAggregation<ProvenanceNode>.\n */\nexport const grouping: NodeAggregator<ProvenanceNode> = {\n  name: \"Grouping\",\n  tests: [testUserIntent, testIsIntervalNode],\n  algorithm: group,\n  arg: false,\n  description: `This algorithm groups nodes of the same category (color).\nThe remaining nodes represent the last interactions of category groups.\nThe grouped nodes must have connectivity equal to two or less (interval nodes or leaves) and must belong to the same category group.`\n};\n\n/**\n * @description Object of the interface DataAggregation<ProvenanceNode>.\n */\nexport const compression: NodeAggregator<ProvenanceNode> = {\n  name: \"Compression\",\n  tests: [testIsIntervalNode, testIsIntervalNode],\n  algorithm: compress,\n  arg: false,\n  description: `This algorithm groups nodes with connectivity equals to two (interval nodes). However,\nthe node which 'absorbs' the grouped nodes and which is still visualized can be of any connectivity\nThe remaining nodes are nodes with connectivity different to two (leaves or subroots).\nThe nodes are grouped regardless their category.`\n};\n\n/**\n * @description Object of the interface DataAggregation<ProvenanceNode>.\n */\nexport const pruning: NodeAggregator<ProvenanceNode> = {\n  name: \"Pruning\",\n  tests: [testIsIntervalNode],\n  algorithm: prune,\n  arg: true,\n  description: `This algorithm groups nodes with connectivity equals to two (interval nodes), regardless their category.\nA chosen parameter indicates the minimum height that a subtree must have to be shown.\nE.g., if the chosen parameter is two, the subtrees with height two or less than two will be grouped.\nThe grouped subtrees are represented by their subroot.\nThe main tree is not considered as a subtree.`\n};\n\n/**\n * @description Object of the interface DataAggregation<ProvenanceNode>.\n */\nexport const plotTrimmer: NodeAggregator<ProvenanceNode> = {\n  name: \"PlotTrimmer\",\n  tests: [testIsIntervalNode],\n  algorithm: plotTrimmerFunc,\n  arg: true,\n  description: \"Lorem Ipsum\"\n};\n\n/**\n * @description Object of the interface DataAggregation<ProvenanceNode>.\n */\nexport const plotTrimmerC: NodeAggregator<ProvenanceNode> = {\n  name: \"PlotTrimmer C\",\n  tests: [testIsIntervalNode],\n  algorithm: plotTrimmerFuncC,\n  arg: true,\n  description: \"Lorem Ipsum\"\n};\n\n/**\n * @description Object of the interface DataAggregation<ProvenanceNode>.\n */\nexport const plotTrimmerG: NodeAggregator<ProvenanceNode> = {\n  name: \"PlotTrimmer G\",\n  tests: [testIsIntervalNode],\n  algorithm: plotTrimmerFuncG,\n  arg: true,\n  description: \"Lorem Ipsum\"\n};\n\n/**\n * @description List of the data aggregation objects. Whenever you want to add a\n * new data aggregation algorithm: create object and add it to this list.\n */\n\nexport const aggregationObjects = [\n  defaultData,\n  rawData,\n  grouping,\n  compression,\n  pruning,\n  plotTrimmer,\n  plotTrimmerC,\n  plotTrimmerG\n];\n\nexport const aggregationObjectsUI1 = [\n  defaultData,\n  rawData,\n  plotTrimmerG\n];\nexport const aggregationObjectsUI2 = [\n  defaultData,\n  rawData,\n  plotTrimmerC\n];","import * as d3 from 'd3';\nimport { ProvenanceTreeVisualization } from './provenance-tree-visualization';\n// import { addLegend, addCommandsList, addTasksList } from './legend';\nimport { StateNode } from '@visualstorytelling/provenance-core';\n\n/**\n * @description Show the title of the data aggregation algorithm used.\n */\nexport type HTMLDivSelection = d3.Selection<\n  HTMLDivElement,\n  unknown,\n  null,\n  undefined\n>;\nexport function setTitle(elm: HTMLDivSelection, onClick: () => any) {\n  elm\n    .append('div')\n    .attr('id', 'DataAggregationTitle')\n    .attr('style', 'text-align: center;')\n    .append('text')\n    .attr('class', 'titleAggregation')\n    .attr('id', 'DataAggregation')\n    .text('Raw Data')\n    .on('click', onClick)\n    .attr('style', 'cursor:pointer');\n}\n\n/**\n * @description Show the buttons of the user interface.\n */\nexport function addAggregationButtons(\n  elm: HTMLDivSelection,\n  provenanceTreeVisualization: ProvenanceTreeVisualization\n) {\n  const container = elm.append('div').attr('class', 'container');\n\n  const holder = provenanceTreeVisualization.container\n    .append(\"div\")\n    .attr(\"class\", \"holder\")\n    .attr(\"id\", \"groupingContainer\")\n    .attr(\"style\", \"position: absolute; bottom: 25%; display:none;\");\n\n  // const holder = container.append('div');\n  // addLegend(container);\n  // addCommandsList(container);\n  // addTasksList(container);\n\n  // legendButton\n\n  // const legendButton = provenanceTreeVisualization.container\n  //   .append('button')\n  //   .attr('id', 'minimap-trigger')\n  //   .attr('class', 'mat-icon-button mat-button-base mat-primary')\n  //   .attr('color', 'primary')\n  //   .attr('style', 'position: absolute; color: orange; z-index: 1; bottom: 1%; left: 1%;')\n  //   .attr('ng-reflect-color', 'primary')\n  //   .on('mousedown', () => {\n  //     const visible = d3.select(\"#legendContainer\").style('display') === 'block';\n  //     if (visible) {\n  //       taskListButton.attr('class', 'mat-icon-button mat-button-base mat-primary')\n  //       commandsListButton.attr('class', 'mat-icon-button mat-button-base mat-primary')\n  //       legendButton.attr('class', 'mat-icon-button mat-button-base mat-primary')\n  //       d3.select(\"#legendContainer\").style('display', 'none');\n  //       d3.select(\"#commandsContainer\").style('display', 'none');\n  //       d3.select(\"#tasksContainer\").style('display', 'none');\n  //       provenanceTreeVisualization.update();\n  //       // provenanceTreeVisualization.scaleToFit();\n  //     } else {\n  //       taskListButton.attr('class', 'mat-icon-button mat-button-base mat-primary')\n  //       commandsListButton.attr('class', 'mat-icon-button mat-button-base mat-primary')\n  //       legendButton.attr('class', 'mat-icon-button mat-button-base mat-primary checked')\n  //       d3.select(\"#legendContainer\").style('display', 'block');\n  //       d3.select(\"#commandsContainer\").style('display', 'none');\n  //       d3.select(\"#tasksContainer\").style('display', 'none');\n  //       provenanceTreeVisualization.update();\n  //       // provenanceTreeVisualization.scaleToFit();\n  //     }\n  //   });\n\n  // legendButton\n  //   .append('span')\n  //   .attr('class', 'mat-button-wrapper')\n  //   .append('mat-icon')\n  //   .attr('class', 'mat-icon notranslate material-icons mat-icon-no-color')\n  //   .attr('role', 'img')\n  //   .attr('aria-hidden', 'true')\n  //   .text('color_lens');\n\n  // legendButton\n  //   .append('div')\n  //   .attr('class', 'mat-button-ripple mat-ripple mat-button-ripple-round')\n  //   .attr('ng-reflect-centered', 'true')\n  //   .attr('ng-reflect-disabled', 'false')\n  //   .attr('ng-reflect-trigger', '[object HTMLButtonElement]');\n\n  // legendButton\n  //   .append('div')\n  //   .attr('class', 'mat-button-focus-overlay');\n\n\n\n  // const commandsListButton = provenanceTreeVisualization.container\n  //   .append('button')\n  //   .attr('id', 'minimap-trigger')\n  //   .attr('class', 'mat-icon-button mat-button-base mat-primary')\n  //   .attr('color', 'primary')\n  //   .attr('style', 'position: absolute; color: orange; z-index: 1; bottom: 1%; left: 8%; ')\n  //   .attr('ng-reflect-color', 'primary')\n  //   .on('mousedown', () => {\n  //     const visible = d3.select(\"#commandsContainer\").style('display') === 'block';\n  //     if (visible) {\n  //       taskListButton.attr('class', 'mat-icon-button mat-button-base mat-primary')\n  //       commandsListButton.attr('class', 'mat-icon-button mat-button-base mat-primary')\n  //       legendButton.attr('class', 'mat-icon-button mat-button-base mat-primary')\n  //       d3.select(\"#legendContainer\").style('display', 'none');\n  //       d3.select(\"#commandsContainer\").style('display', 'none');\n  //       d3.select(\"#tasksContainer\").style('display', 'none');\n  //       provenanceTreeVisualization.update();\n  //       // provenanceTreeVisualization.scaleToFit();\n  //     } else {\n  //       taskListButton.attr('class', 'mat-icon-button mat-button-base mat-primary')\n  //       commandsListButton.attr('class', 'mat-icon-button mat-button-base mat-primary checked')\n  //       legendButton.attr('class', 'mat-icon-button mat-button-base mat-primary')\n  //       d3.select(\"#legendContainer\").style('display', 'none');\n  //       d3.select(\"#commandsContainer\").style('display', 'block');\n  //       d3.select(\"#tasksContainer\").style('display', 'none');\n  //       provenanceTreeVisualization.update();\n  //       // provenanceTreeVisualization.scaleToFit();\n  //     }\n  //   });\n\n  // commandsListButton\n  //   .append('span')\n  //   .attr('class', 'mat-button-wrapper')\n  //   .append('mat-icon')\n  //   .attr('class', 'mat-icon notranslate material-icons mat-icon-no-color')\n  //   .attr('role', 'img')\n  //   .attr('aria-hidden', 'true')\n  //   .text('list');\n\n  // commandsListButton\n  //   .append('div')\n  //   .attr('class', 'mat-button-ripple mat-ripple mat-button-ripple-round')\n  //   .attr('ng-reflect-centered', 'true')\n  //   .attr('ng-reflect-disabled', 'false')\n  //   .attr('ng-reflect-trigger', '[object HTMLButtonElement]');\n\n  // commandsListButton\n  //   .append('div')\n  //   .attr('class', 'mat-button-focus-overlay');\n\n\n\n\n\n  // const taskListButton = provenanceTreeVisualization.container\n  //   .append('button')\n  //   .attr('id', 'minimap-trigger')\n  //   .attr('class', 'mat-icon-button mat-button-base mat-primary')\n  //   .attr('color', 'primary')\n  //   .attr('style', 'position: absolute; color: orange; z-index: 1; bottom: 1%; left: 15%;')\n  //   .attr('ng-reflect-color', 'primary')\n  //   .on('mousedown', () => {\n  //     const visible = d3.select(\"#tasksContainer\").style('display') === 'block';\n  //     if (visible) {\n  //       taskListButton.attr('class', 'mat-icon-button mat-button-base mat-primary')\n  //       commandsListButton.attr('class', 'mat-icon-button mat-button-base mat-primary')\n  //       legendButton.attr('class', 'mat-icon-button mat-button-base mat-primary')\n  //       d3.select(\"#legendContainer\").style('display', 'none');\n  //       d3.select(\"#commandsContainer\").style('display', 'none');\n  //       d3.select(\"#tasksContainer\").style('display', 'none');\n  //       provenanceTreeVisualization.update();\n  //       // provenanceTreeVisualization.scaleToFit();\n  //     } else {\n  //       taskListButton.attr('class', 'mat-icon-button mat-button-base mat-primary checked')\n  //       commandsListButton.attr('class', 'mat-icon-button mat-button-base mat-primary')\n  //       legendButton.attr('class', 'mat-icon-button mat-button-base mat-primary')\n  //       d3.select(\"#legendContainer\").style('display', 'none');\n  //       d3.select(\"#commandsContainer\").style('display', 'none');\n  //       d3.select(\"#tasksContainer\").style('display', 'block');\n  //       provenanceTreeVisualization.update();\n  //       // provenanceTreeVisualization.scaleToFit();\n  //     }\n  //   });\n\n  // taskListButton\n  //   .append('span')\n  //   .attr('class', 'mat-button-wrapper')\n  //   .append('mat-icon')\n  //   .attr('class', 'mat-icon notranslate material-icons mat-icon-no-color')\n  //   .attr('role', 'img')\n  //   .attr('aria-hidden', 'true')\n  //   .text('done');\n\n  // taskListButton\n  //   .append('div')\n  //   .attr('class', 'mat-button-ripple mat-ripple mat-button-ripple-round')\n  //   .attr('ng-reflect-centered', 'true')\n  //   .attr('ng-reflect-disabled', 'false')\n  //   .attr('ng-reflect-trigger', '[object HTMLButtonElement]');\n\n  // taskListButton\n  //   .append('div')\n  //   .attr('class', 'mat-button-focus-overlay');\n\n\n\n\n\n  const goToTheRootButton = provenanceTreeVisualization.container\n    .append('button')\n    .attr('id', 'downward-trigger')\n    .attr('class', 'mat-icon-button mat-button-base mat-primary')\n    .attr('color', 'primary')\n    .attr('style', 'position: absolute; z-index: 1; top: 2%;')\n    .attr('ng-reflect-color', 'primary')\n    .on('mousedown', () => {\n      if (provenanceTreeVisualization.traverser.graph.root) {\n        provenanceTreeVisualization.getFullsizeview();\n      }\n    });\n\n  goToTheRootButton\n    .append('span')\n    .attr('class', 'mat-button-wrapper')\n    .append('mat-icon')\n    .attr('class', 'mat-icon notranslate material-icons mat-icon-no-color')\n    .attr('role', 'img')\n    .attr('aria-hidden', 'true')\n    .text('radio_button_unchecked');\n\n  goToTheRootButton\n    .append('div')\n    .attr('class', 'mat-button-ripple mat-ripple mat-button-ripple-round')\n    .attr('ng-reflect-centered', 'true')\n    .attr('ng-reflect-disabled', 'false')\n    .attr('ng-reflect-trigger', '[object HTMLButtonElement]');\n\n  goToTheRootButton\n    .append('div')\n    .attr('class', 'mat-button-focus-overlay');\n\n\n\nconst upwardButton = provenanceTreeVisualization.container\n  .append('button')\n  .attr('id', 'upward-trigger')\n  .attr('class', 'mat-icon-button mat-button-base mat-primary')\n  .attr('color', 'primary')\n  .attr('style', 'position: absolute; z-index: 1; top: 7%;')\n  .attr('ng-reflect-color', 'primary')\n  .on('mousedown', () => {\n    if (provenanceTreeVisualization.traverser.graph.current.label !== 'Root') {\n      provenanceTreeVisualization.traverser.toStateNode((provenanceTreeVisualization.traverser.graph.current as StateNode).parent.id, 250);\n      provenanceTreeVisualization.update();\n    }\n  });\n\nupwardButton\n  .append('span')\n  .attr('class', 'mat-button-wrapper')\n  .append('mat-icon')\n  .attr('class', 'mat-icon notranslate material-icons mat-icon-no-color')\n  .attr('role', 'img')\n  .attr('aria-hidden', 'true')\n  .text('arrow_upward');\n\nupwardButton\n  .append('div')\n  .attr('class', 'mat-button-ripple mat-ripple mat-button-ripple-round')\n  .attr('ng-reflect-centered', 'true')\n  .attr('ng-reflect-disabled', 'false')\n  .attr('ng-reflect-trigger', '[object HTMLButtonElement]');\n\nupwardButton\n  .append('div')\n  .attr('class', 'mat-button-focus-overlay');\n\n\n\n\n\n\n\n\n\nconst downwardButton = provenanceTreeVisualization.container\n  .append('button')\n  .attr('id', 'downward-trigger')\n  .attr('class', 'mat-icon-button mat-button-base mat-primary')\n  .attr('color', 'primary')\n  .attr('style', 'position: absolute; z-index: 1; top: 12%;')\n  .attr('ng-reflect-color', 'primary')\n  .on('mousedown', () => {\n    if (provenanceTreeVisualization.traverser.graph.current.children[0]) {\n      for (const child of provenanceTreeVisualization.traverser.graph.current.children) {\n        if (child.metadata.mainbranch) {\n          provenanceTreeVisualization.traverser.toStateNode(provenanceTreeVisualization.traverser.graph.current.children[0].id, 250);\n          provenanceTreeVisualization.update();\n        }\n      }\n    }\n  });\n\ndownwardButton\n  .append('span')\n  .attr('class', 'mat-button-wrapper')\n  .append('mat-icon')\n  .attr('class', 'mat-icon notranslate material-icons mat-icon-no-color')\n  .attr('role', 'img')\n  .attr('aria-hidden', 'true')\n  .text('arrow_downward');\n\ndownwardButton\n  .append('div')\n  .attr('class', 'mat-button-ripple mat-ripple mat-button-ripple-round')\n  .attr('ng-reflect-centered', 'true')\n  .attr('ng-reflect-disabled', 'false')\n  .attr('ng-reflect-trigger', '[object HTMLButtonElement]');\n\ndownwardButton\n  .append('div')\n  .attr('class', 'mat-button-focus-overlay');\n\n\n}\n\n\n\n\n\n/**\n * @description Slider for Arguments in simple HTML\n */\nexport function addSlider<T extends HTMLElement>(\n  elem: d3.Selection<T, any, any, any>,\n  onChange: (val: number) => any\n): void {\n  const container = elem.append('div');\n\n  container.attr('class', 'sliderContainer');\n  container.attr('style', 'visibility: hidden');\n\n  const slider = container\n    .append('input')\n    .attr('id', 'arg')\n    .attr('type', 'range')\n    .attr('min', 0)\n    .attr('max', 10)\n    .attr('value', '0')\n    .attr('class', 'slider');\n  const currentValue = container.append('span').text(0);\n\n  slider.on('change', () => {\n    const val = parseInt(slider.node()!.value, 10);\n    currentValue.text(val);\n    onChange(val);\n  });\n}\nfunction showSlider(value: string) {\n  const slider = d3.select('.sliderContainer');\n  switch (value) {\n    case 'Pruning':\n    case 'PlotTrimmer':\n    case 'PlotTrimmer C':\n    case 'PlotTrimmer G':\n      slider.attr('style', 'display:block');\n      break;\n    default:\n      slider.attr('style', 'display: none');\n  }\n}\n","import * as d3 from \"d3\";\nimport {\n  ProvenanceNode,\n  NodeIdentifier\n} from \"@visualstorytelling/provenance-core\";\n\nimport { IGroupedTreeNode } from \"../utils\";\nimport { IAggregation } from \"../provenance-tree-visualization\";\n\n/**\n * @description Return the HierarchyNode corresponding to the ProvenanceNode.\n */\nexport function findHierarchyNodeFromProvenanceNode(\n  hierarchyNode: d3.HierarchyNode<IGroupedTreeNode<ProvenanceNode>>,\n  currentNode: ProvenanceNode\n) {\n  let currentHierarchyNode: typeof hierarchyNode | undefined;\n  hierarchyNode.each(node => {\n    if (node.data.wrappedNodes.includes(currentNode)) {\n      currentHierarchyNode = node;\n    }\n  });\n\n  if (currentHierarchyNode === undefined) {\n    throw new Error(\"Cannot find current selected node in tree.\");\n  }\n\n  return currentHierarchyNode;\n}\n\nexport function aggregateNodes(\n  aggregation: IAggregation,\n  rootNode: IGroupedTreeNode<ProvenanceNode>,\n  currentNode: ProvenanceNode\n): void {\n  // d3.hierarchy wraps nodes recursively and adds some helpers\n  // See https://github.com/d3/d3-hierarchy#hierarchy\n  const hierarchyRoot: d3.HierarchyNode<\n    IGroupedTreeNode<ProvenanceNode>\n  > = d3.hierarchy(rootNode);\n\n  // the HierarchyNode containing the active ProvenanceTree node\n  const currentHierarchyNode = findHierarchyNodeFromProvenanceNode(\n    hierarchyRoot,\n    currentNode\n  );\n\n  const mainBranch: NodeIdentifier[] = hierarchyRoot\n    .path(currentHierarchyNode)\n    .map(d => d.data.wrappedNodes[0].id);\n\n  // if (this.dataAggregation.arg) {\n  aggregation.aggregator.algorithm(\n    currentHierarchyNode.data,\n    rootNode,\n    aggregation.aggregator.tests,\n    mainBranch,\n    aggregation.arg\n  );\n  // } else {\n  //   this.dataAggregation.algorithm(currentHierarchyNode.data, rootNode, this.dataAggregation.test);\n  // }\n}\n","import { HierarchyNode, HierarchyPointNode } from \"d3-hierarchy\";\n\nfunction depthSort(\n  a: IHierarchyPointNodeWithMaxDepth<any>,\n  b: IHierarchyPointNodeWithMaxDepth<any>\n) {\n  if (a.maxDescendantDepth > b.maxDescendantDepth) {\n    return -1;\n  } else if (a.maxDescendantDepth < b.maxDescendantDepth) {\n    return 1;\n  }\n  return 0;\n}\n\nexport interface IGratzlLayout<Datum> {\n  (\n    root: HierarchyNode<Datum>,\n    activeNode: HierarchyNode<Datum>\n  ): IHierarchyPointNodeWithMaxDepth<Datum>;\n  size(): [number, number];\n  size(size: [number, number]): this;\n}\n\nexport interface IHierarchyPointNodeWithMaxDepth<Datum>\n  extends HierarchyPointNode<Datum> {\n  maxDescendantDepth: number;\n  xOffset: number;\n}\n\nexport default function GratzlLayoutOld<Datum>() {\n  let dx = 5;\n  let dy = 50;\n  const widths: number[] = [];\n\n  function setTreeX(node: IHierarchyPointNodeWithMaxDepth<Datum>, val: number) {\n    node.xOffset = val;\n    widths[node.depth] = val;\n    if (node.children) {\n      node\n        .leaves()\n        .sort(depthSort)\n        .forEach(leaf => {\n          if (typeof leaf.xOffset === \"undefined\") {\n            const width = Math.max.apply(\n              null,\n              widths.slice(node.depth, leaf.depth + 1)\n            );\n            setTreeX(leaf, val > width ? val : width + 1);\n          }\n        });\n    }\n\n    if (node.parent && typeof node.parent.xOffset === \"undefined\") {\n      setTreeX(node.parent, val);\n    }\n  }\n\n  const tree: IGratzlLayout<Datum> = Object.assign(\n    (_root: HierarchyNode<Datum>, _activeNode: HierarchyNode<Datum>) => {\n      /*\n       * set maxDescendantDepth on each node,\n       * which is the depth of its deepest child\n       *\n       * */\n\n      const root = _root as IHierarchyPointNodeWithMaxDepth<Datum>;\n      const activeNode = _activeNode as IHierarchyPointNodeWithMaxDepth<Datum>;\n\n      root.leaves().forEach(leaf => {\n        leaf.ancestors().forEach(leafAncestor => {\n          if (\n            !leafAncestor.maxDescendantDepth ||\n            leaf.depth > leafAncestor.maxDescendantDepth\n          ) {\n            leafAncestor.maxDescendantDepth = leaf.depth;\n          }\n        });\n      });\n\n      /* rendering should start at the deepest leaf of activeNode. */\n      let deepestLeaf = activeNode;\n      activeNode.leaves().forEach(leaf => {\n        if (deepestLeaf.depth < leaf.depth) {\n          deepestLeaf = leaf;\n        }\n      });\n\n      setTreeX(deepestLeaf, 0);\n\n      const maxX = Math.max.apply(null, widths);\n      const maxY = Math.max.apply(null, root.leaves().map(leaf => leaf.depth));\n      root.each(node => {\n        sizeNode(node, maxX, maxY);\n      });\n\n      return root;\n    },\n    {\n      size: ((x: [number, number] | undefined) => {\n        return x ? ((dx = +x[0]), (dy = +x[1]), tree) : [dx, dy];\n      }) as any\n    }\n  );\n\n  function sizeNode(\n    node: IHierarchyPointNodeWithMaxDepth<any>,\n    maxX: number,\n    maxY: number\n  ): void {\n    node.x = maxX === 0 ? dx : dx - (dx / maxX) * node.xOffset;\n    node.y = maxY === 0 ? dy : (dy / maxY) * node.depth;\n  }\n\n  return tree;\n}\n","import { getNodeIntent, isKeyNode } from \"./aggregation/aggregation-objects\";\nimport { IHierarchyPointNodeWithMaxDepth } from \"./gratzl\";\nimport GratzlLayoutOld from \"./gratzl_old\";\nimport { IGroupedTreeNode } from \"./utils\";\nimport { ProvenanceNode } from \"@visualstorytelling/provenance-core\";\nimport { HierarchyPointLink } from \"d3-hierarchy\";\nimport { ProvenanceTreeVisualization } from \"./provenance-tree-visualization\";\nimport * as d3 from \"d3\";\n\nexport function caterpillar(\n  updateNodes: d3.Selection<\n    any,\n    IHierarchyPointNodeWithMaxDepth<IGroupedTreeNode<ProvenanceNode>>,\n    any,\n    any\n  >,\n  treeNodes: IHierarchyPointNodeWithMaxDepth<\n    IGroupedTreeNode<ProvenanceNode>\n  >[],\n  updatedLinks: d3.Selection<\n    any,\n    HierarchyPointLink<IGroupedTreeNode<ProvenanceNode>>,\n    any,\n    any\n  >,\n  provenanceTreeVisualization: ProvenanceTreeVisualization\n) {\n  if (provenanceTreeVisualization.caterpillarActivated) {\n    const mainNodes = updateNodes.filter((d: any) => d.x === 0);\n    const mainNodesData = mainNodes\n      .data()\n      .map((d: any) => d.data.wrappedNodes[0].id);\n\n    // console.log(mainNodesData);\n\n    const edgeNodes = mainNodes.filter((d: any) => {\n      if (d.children) {\n        return d.children.length > 1;\n      }\n      return false;\n    });\n\n    edgeNodes.select(\"circle\").attr(\"class\", \"intent_wrapped\");\n    edgeNodes.select(\"rect\").attr(\"class\", \"intent_wrapped\");\n\n    // Hide the rest of the circles and links\n    updateNodes.filter((d: any) => d.x !== 0).attr(\"class\", \"node hiddenClass\");\n\n    updatedLinks\n      .filter((d: any) => d.target.x !== 0)\n      .attr(\"class\", \"node hiddenClass\");\n\n    // Set the label which indicate the number of nodes wrapped\n    updateNodes\n      .select(\"text.circle-text\")\n      .filter((d: any) => d.x !== 0)\n      .attr(\"visibility\", \"visible\");\n\n    edgeNodes\n      .select(\".normal>text.circle-text\")\n      .attr(\"visibility\", \"visible\")\n      .text((d: any) => {\n        const copyNode = d.copy();\n        copyNode.children = copyNode.children.filter(\n          (e: any, i: any, arr: any) =>\n            !mainNodesData.includes(e.data.wrappedNodes[0].id)\n        );\n        return copyNode.descendants().length;\n      })\n      .attr(\"x\", (d: any) => {\n        const copyNode = d.copy();\n        copyNode.children = copyNode.children.filter(\n          (e: any, i: any, arr: any) =>\n            !mainNodesData.includes(e.data.wrappedNodes[0].id)\n        );\n        if (copyNode.descendants().length < 10) {\n          return -1.5;\n        } else {\n          return -3;\n        }\n      });\n\n    // Set the radius of the circle\n    edgeNodes.select(\"circle\").attr(\"r\", (d: any) => {\n      return Math.min(4 + 0.15 * d.descendants().length, 6);\n    });\n\n    // Set the click function\n    edgeNodes.on(\"click\", (d: any) => {\n      const actualCatGraph = d3.selectAll(\".classCat\");\n\n      // When click again -> auxiliar tree disappearss.\n      if (\n        actualCatGraph\n          .data()\n          .map((k: any) => k.data.wrappedNodes[0].id)\n          .includes(d.data.wrappedNodes[0].id)\n      ) {\n        actualCatGraph\n          .data([])\n          .exit()\n          .remove();\n        d3.selectAll(\"path.linkCat\")\n          .data([])\n          .exit()\n          .remove();\n        // console.log(\n        //   actualCatGraph.data().map((k: any) => k.data.wrappedNodes[0].id)\n        // );\n        // console.log(d.data.wrappedNodes[0].id);\n      } else {\n        // else -> deploy the new tree.\n        const treeCopy = d.copy();\n        treeCopy.children = treeCopy.children.filter(\n          (e: any, i: any, arr: any) =>\n            !mainNodesData.includes(e.data.wrappedNodes[0].id)\n        );\n        const treeLayoutCat = GratzlLayoutOld<\n          IGroupedTreeNode<ProvenanceNode>\n        >().size([35, 120]);\n        const treeCat = treeLayoutCat(treeCopy, treeCopy);\n\n        const excatNodes = provenanceTreeVisualization.g\n          .selectAll(\"g.classCat\")\n          .data(treeCat.descendants(), (datum: any) =>\n            datum.data.wrappedNodes.map((n: any) => n.id).join()\n          );\n        excatNodes.exit().remove();\n\n        const catNodes = excatNodes\n          .enter()\n          .append(\"g\")\n          .attr(\"class\", \"classCat node branch-active \")\n          .data(treeNodes)\n          .attr(\"transform\", (datum: any) =>\n            datum.data.wrappedNodes[0].metadata.isSlideAdded\n              ? `translate(${d.x - 3}, ${d.y})`\n              : `translate(${d.x}, ${d.y})`\n          );\n        // .append('g')\n        // .attr('class', 'classCat node branch-active ')\n        // .attr('transform', (k: any) => `translate(${k.x}, ${k.y})`);\n\n        catNodes.append(\"circle\").attr(\"r\", 3);\n\n        // Fix the radius of the circles according to #nodes wrapped\n        catNodes.select(\"circle\").attr(\"r\", (datum: any) => {\n          let radius = 2;\n          if (datum.data.neighbour === true) {\n            radius = 3;\n          }\n          if (datum.data.wrappedNodes.length !== 1) {\n            radius = Math.min(4 + 0.15 * datum.data.wrappedNodes.length, 6);\n          }\n          return radius;\n        });\n\n        // Assign classes to the circles\n        catNodes.select(\"circle\").attr(\"class\", (datum: any) => {\n          let classString = \"\";\n          console.log(d.data.wrappedNodes[0].metadata);\n          if (d.data.wrappedNodes[0].metadata.bookmarked === true) {\n            classString += ' bookmarked';\n          }\n          if (isKeyNode(datum.data.wrappedNodes[0])) {\n            classString += \" keynode\";\n          }\n          classString += \" intent_\" + getNodeIntent(d.data.wrappedNodes[0]);\n\n          return classString;\n        });\n\n        catNodes.on(\"click\", datum =>\n          provenanceTreeVisualization.traverser.toStateNode(\n            datum.data.wrappedNodes[0].id,\n            250\n          )\n        );\n\n        // Set the #nodes-wrapped label\n        catNodes\n          .append(\"text\")\n          .attr(\"class\", \"circle-text\")\n          .attr(\"visibility\", (datum: any) => {\n            if (datum.data.wrappedNodes.length === 1) {\n              return \"hidden\";\n            } else {\n              return \"visible\";\n            }\n          })\n          .attr(\"x\", (datum: any) => {\n            if (datum.data.wrappedNodes.length >= 10) {\n              return -3;\n            }\n            return -1.5;\n          })\n          .attr(\"y\", 2)\n          .text((datum: any) => datum.data.wrappedNodes.length.toString());\n\n        // Set the links between circles\n        const oldLinksCat = provenanceTreeVisualization.g\n          .selectAll(\"path.linkCat\")\n          .data(treeCat.links(), (datum: any) =>\n            datum.target.data.wrappedNodes.map((n: any) => n.id).join()\n          );\n\n        oldLinksCat.exit().remove();\n\n        const newLinksCat = oldLinksCat\n          .enter()\n          .insert(\"path\", \"g\")\n          .attr(\"d\", provenanceTreeVisualization.linkPath as any);\n        oldLinksCat\n          .merge(newLinksCat as any)\n          .attr(\"class\", \"link linkCat\")\n          .filter((datum: any) => datum.target.x === 0)\n          .attr(\"class\", \"link active linkCat\");\n      } // end else actualgraph\n    }); // end on click\n  } // if of caterpillar procedure\n}\n","import * as d3 from 'd3';\nimport { HierarchyPointNode } from 'd3';\nimport { ProvenanceGraphTraverser, ProvenanceNode } from '@visualstorytelling/provenance-core';\n\nimport gratzl from './gratzl';\nimport { IHierarchyPointNodeWithMaxDepth } from './gratzl';\nimport { IGroupedTreeNode } from './utils';\nimport { NodeAggregator } from './aggregation/aggregation-implementations';\n\nimport {\n  getNodeIntent,\n  getNodeRenderer,\n  groupNodeLabel,\n  isKeyNode,\n  rawData,\n  wrapNode,\n  plotTrimmerC,\n  plotTrimmerG\n} from './aggregation/aggregation-objects';\nimport { addAggregationButtons } from './components';\nimport { findHierarchyNodeFromProvenanceNode } from './aggregation/aggregation';\nimport { caterpillar } from './caterpillar';\n\nvar xScale = -20;\nvar yScale = 20;\nvar treeWidth = 0;\nvar maxtreeWidth = 10;\nvar p = 3;\nconst fontSize = 8;\n\nexport type D3SVGSelection = d3.Selection<SVGSVGElement, any, null, undefined>;\nexport type D3SVGGSelection = d3.Selection<SVGGElement, any, null, undefined>;\n\nexport interface IAggregation {\n  aggregator: NodeAggregator<ProvenanceNode>;\n  arg: any;\n}\n\n/**\n * @description Class used to create and manage a provenance tree visualization.\n * @param traverser {ProvenanceGraphTraverser} - To manage the data structure of the graph.\n * @param svg {D3SVGSelection} - To manage the graphics of the tree.\n * @param _dataAggregation {aggregator<ProvenanceNode>} - Data aggregation in use.\n * @param caterpillarActivated {boolean} - True if this feature is enable.\n */\nexport class ProvenanceTreeVisualization {\n  public traverser: ProvenanceGraphTraverser;\n  public colorScheme: any;\n  public g: D3SVGGSelection;\n  public svg: D3SVGSelection;\n  public container: any;\n  public aggregation: IAggregation = {\n    aggregator: rawData,\n    arg: 1\n  };\n  public caterpillarActivated = false;\n  private hierarchyRoot:\n    | IHierarchyPointNodeWithMaxDepth<IGroupedTreeNode<ProvenanceNode>>\n    | undefined;\n\n  private zoomer: any;\n  private currentHierarchyNodelength: any = 0;\n  \n  private TreeLength: any = 0;\n  private TreeWidth: any = 0.1;\n\n  public mergingEnabled: boolean = false;\n  public transferringEnabled: boolean = false;\n  public copyingEnabled: boolean = false;\n\n  constructor(traverser: ProvenanceGraphTraverser, elm: HTMLDivElement) {\n    this.traverser = traverser;\n    this.colorScheme = d3.scaleOrdinal(d3.schemeAccent);\n    this.container = d3.select(elm)\n      .append('div')\n      .attr('class', 'visualizationContainer')\n      .attr('style', 'height:' + `${window.innerHeight - 178}` + 'px');\n\n    // provGraphControls(this);\n\n    // Append svg element\n    this.svg = this.container\n      .append('div')\n      .attr('style', ' width: 95%; margin-left:5px;flex: 4')\n      .append('svg')\n      .attr(\n        'style',\n        `overflow: visible; width: 100%; height: 100%; font-size: ${fontSize}px; line-height: ${fontSize}px`\n      );\n\n    this.g = this.svg.append('g');\n\n    // Append grouping buttons\n    addAggregationButtons(this.container, this);\n\n    traverser.graph.on('currentChanged', () => {\n      this.update();\n    });\n\n    traverser.graph.on('nodeChanged', () => {\n      this.update();\n    });\n\n    traverser.graph.on('nodeAdded', () => {\n      this.currentHierarchyNodelength += 1.0;\n      this.scaleToFit();\n    });\n\n    this.update();\n    this.zoomer = d3.zoom() as any;\n    this.setZoomExtent();\n    this.svg.call(this.zoomer);\n  }\n  public setZoomExtent() {\n    this.zoomer.scaleExtent([0.25, 2.5]).on('zoom', () => {\n      this.g.attr('transform', (d3 as any).event.transform);\n    });\n    this.scaleToFit();\n  }\n\n  public scaleToFit() {\n    const sizeX = this.svg.node()!.clientWidth;\n    const sizeY = this.svg.node()!.clientHeight;\n    const maxScale = 3;\n    const magicNum = 0.75; // todo: get relevant number based on dimensions\n    const relY = sizeY * 4 - (yScale * maxScale * this.currentHierarchyNodelength);\n    // console.log(sizeY/2);\n    // const scaleFactor = Math.min(\n    //   maxScale,\n    //   Math.pow(magicNum,this.y_zoom-maxScale) * maxScale \n    // );\n    this.svg\n      .transition()\n      .duration(0)\n      .call(this.zoomer.transform, () =>\n        d3.zoomIdentity.translate(sizeX / 2, relY).scale(maxScale) // fix size\n      );\n  }\n\n  public linkPath({\n    source,\n    target\n  }: {\n    source: HierarchyPointNode<IGroupedTreeNode<ProvenanceNode>>;\n    target: HierarchyPointNode<IGroupedTreeNode<ProvenanceNode>>;\n  }): string {\n    const [s, t] = [source, target];\n\n    // tslint:disable-next-line\n    return `M${s.x * xScale},${s.y * yScale}\n              C${s.x * xScale},  ${(s.y * yScale + t.y * yScale) / 2} ${t.x *\n      xScale},  ${(s.y * yScale + t.y * yScale) / 2} ${t.x * xScale},  ${t.y *\n      yScale}`;\n  }\n  /**\n   * @descriptionWrap text labels\n   */\n  public wrap(text: any, width: any) {\n    text.each(function () {\n      const words = text\n        .text()\n        .split(/(?=[A-Z])/)\n        .reverse();\n      let word,\n        line = [],\n        lineNumber = 0;\n      const lineHeight = 1.0, // ems\n        y = text.attr('y'),\n        dy = 0;\n      let tspan = text\n        .text(null)\n        .append('tspan')\n        .attr('x', 7)\n        .attr('y', y)\n        .attr('dy', dy + 'em');\n      while ((word = words.pop())) {\n        line.push(word);\n        tspan.text(line.join(' '));\n        if (tspan.node().getComputedTextLength() > width) {\n          line.pop();\n          tspan.text(line.join(' '));\n          line = [word];\n          tspan = text\n            .append('tspan')\n            .attr('x', 7)\n            .attr('y', y)\n            .attr('dy', ++lineNumber * lineHeight + dy + 'em')\n            .text(word);\n        }\n      }\n    });\n  }\n\n  public getFullsizeview(): void {\n    let sizeX = this.svg.node()!.clientWidth;\n    let sizeY = this.svg.node()!.clientHeight;\n    const maxScale = 3;\n    let magicNum_W = 0.25;\n    let magicNum_H = 0.7; // todo: get relevant number based on dimensions\n    if(this.TreeLength<=14)\n      magicNum_H = 1.4;\n    else if(this.TreeLength<=24)\n      magicNum_H = 1.3;\n    else\n      magicNum_H = 1.0;\n    if(this.TreeWidth>=4)\n      sizeX = sizeX + 100;\n    //Need to Modify\n    const scaleFactor = Math.min(\n      maxScale,\n      maxScale - (magicNum_H * (this.TreeLength)/15),\n      maxScale - (magicNum_W * this.TreeWidth)\n    ); // find the smallest scale(Length, Width, )\n    this.svg\n    .transition()\n    .duration(0)\n    .call(this.zoomer.transform, () =>\n      d3.zoomIdentity.translate(sizeX / 2, 40).scale(scaleFactor) // fix size\n    );\n  }\n\n\n  public setTraverser(traverser: ProvenanceGraphTraverser): void {\n    this.traverser = traverser;\n  }\n\n  /**\n   * @description Update the tree layout.\n   */\n  public update() {\n    const wrappedRoot = wrapNode(this.traverser.graph.root);\n    // aggregateNodes(this.aggregation, wrappedRoot, this.traverser.graph.current);\n    const hierarchyRoot = d3.hierarchy(wrappedRoot); // Updated de treeRoot\n    \n    const currentHierarchyNode = findHierarchyNodeFromProvenanceNode(\n      hierarchyRoot,\n      this.traverser.graph.current\n    );\n    this.currentHierarchyNodelength = hierarchyRoot.path(currentHierarchyNode).length;\n    const tree = gratzl(hierarchyRoot, currentHierarchyNode);\n    this.hierarchyRoot = tree;\n    // console.log(tree);\n    const treeNodes = tree.descendants().filter((d: any) => d.data.wrappedNodes[0].metadata.option !== 'merged');\n    const treemaxwidth = tree.descendants().map(function (item) {return item.x}).reduce(function(prev, current) {return (prev > current) ? prev : current});\n    const treemaxlength = tree.descendants().map(function (item) {return item.y}).reduce(function(prev, current) {return (prev > current) ? prev : current});\n    const oldNodes = this.g.selectAll('g.node').data(treeNodes, (d: any) => {\n      const data = d.data.wrappedNodes.map((n: any) => n.id).join();\n      return data;\n    });\n    // console.log(treemaxwidth);\n    this.TreeWidth = Math.max(this.TreeWidth,treemaxwidth);\n    this.TreeLength = Math.max(this.TreeLength,treemaxlength);\n    oldNodes.exit().remove();\n    // group wrapping a node\n    const newNodes = oldNodes\n      .enter()\n      .append('g')\n      .attr('class', 'node')\n      .attr(\n        'transform',\n        (d: any) => `translate(${d.x * xScale}, ${d.y * yScale})`\n      );\n\n    // node label\n    newNodes\n      .append('text')\n      .attr('class', 'circle-label')\n      .text(d => groupNodeLabel(d.data)) // .text(d => d.data.neighbour.toString())\n      .attr('x', 7)\n      .attr('alignment-baseline', 'central');\n    // .call(this.wrap, 70);\n\n    const updateNodes = newNodes.merge(oldNodes as any);\n\n    updateNodes.selectAll('g.normal').remove();\n    updateNodes.selectAll('g.bookmarked').remove();\n    updateNodes.selectAll('.circle-text').remove();\n\n    const getNodeSize = (node: IGroupedTreeNode<ProvenanceNode>) => {\n      return Math.min(2.7 + 0.3 * node.wrappedNodes.length, 7);\n    };\n\n    // other nodes to circle\n    updateNodes\n      .filter((d: any) => {\n        return !d.data.wrappedNodes.some(\n          (node: ProvenanceNode) => node.metadata.isSlideAdded\n        );\n      })\n      .append('g')\n      .attr('class', 'normal');\n\n\n    updateNodes.on('contextmenu', (d: any) => {\n      this.traverser.graph.current = this.traverser.graph.getNode(d.data.wrappedNodes[0].id);\n      this.update();\n      d.data.wrappedNodes[0].metadata.bookmarked = !d.data.wrappedNodes[0].metadata.bookmarked;\n      if (!d.data.wrappedNodes[0].metadata.bookmarked) {\n        (window as any).slideDeck.onDelete(null, this.traverser.graph.current);\n      } else {\n        (window as any).slideDeck.onAdd(this.traverser.graph.current);\n      }\n    });\n\n\n    // set classes on node\n    updateNodes\n        .attr('class', 'node')\n        .filter((d: any) => {\n        if (d.x === 0) {\n          d.data.wrappedNodes[0].metadata.mainbranch = true;\n        }\n        return d.x === 0;\n      })\n      .attr('class', 'node branch-active')\n      .filter((d: any) => {\n        let neighbourNode: boolean = false;\n        if ((this.traverser.graph.current as any).parent) {\n          neighbourNode = (this.traverser.graph.current as any).parent === d.data.wrappedNodes[0] ? true : neighbourNode;\n          d.data.wrappedNodes[0].metadata.neighbour = neighbourNode ? true : neighbourNode;\n        }  \n        if ((this.traverser.graph.current as any).children.length !== 0) {\n          for (const child of (this.traverser.graph.current as any).children){\n            neighbourNode = d.data.wrappedNodes.includes(child) ? true : neighbourNode;\n            d.data.wrappedNodes[0].metadata.neighbour = neighbourNode ? true : neighbourNode;\n          }\n        }\n        return neighbourNode;\n      })      \n      .attr('class', 'node branch-active neighbour');\n\n\n      updateNodes\n      .filter((d: any) => {\n        const ref = d.data.wrappedNodes.includes(this.traverser.graph.current);\n        return ref;\n      })\n      .attr('class', 'node branch-active neighbour node-active');\n\n\n    updateNodes\n      .select('g')\n      .append('circle')\n      .attr('class', (d: any) => {\n        let classString = '';\n        if (d.data.wrappedNodes[0].metadata.bookmarked === true) {\n          classString += ' bookmarked';\n        } else if (d.data.wrappedNodes[0].metadata.loaded === true) {\n          classString += ' loaded';\n        }\n        if (isKeyNode(d.data.wrappedNodes[0])) {\n          classString += ' keynode';\n        }\n        classString += ' intent_' + getNodeIntent(d.data.wrappedNodes[0]);\n        return classString;\n      })\n      .attr('r', (d: any) => {\n        let nodeSize: number = getNodeSize(d.data);\n        if (d.data.wrappedNodes[0].metadata.neighbour === true) {\n          nodeSize = getNodeSize(d.data) * 1.15;\n        }\n        if (d.data.wrappedNodes.includes(this.traverser.graph.current)) {\n          nodeSize = getNodeSize(d.data) * 1.3;\n        }\n        return nodeSize;\n      });\n\n\n\n    // hide labels not in branch\n    updateNodes\n      .select('text.circle-label')\n      .attr('class', (d: any) => 'circle-label renderer_' + getNodeRenderer(d.data.wrappedNodes[0]))\n      .attr('visibility', (d: any) => (d.x === 0 ? 'visible' : 'hidden'));\n\n    updateNodes.on('click', d => {\n      if(d.data.wrappedNodes[0].id !== this.traverser.graph.current.id){\n        this.traverser.toStateNode(d.data.wrappedNodes[0].id, 250);\n        this.update();\n      }\n    });\n\n\n    updateNodes\n      .data(treeNodes)\n      .transition()\n      .duration(500)\n      .attr(\n        'transform',\n        (d: any) => {\n          if (d.x > treeWidth && treeWidth <= maxtreeWidth) {\n            var classString = `translate(${d.x * xScale}, ${d.y * yScale})`;\n            treeWidth = d.x;\n            if (treeWidth % p) {\n            }\n          } else {\n            var classString = `translate(${d.x * xScale}, ${d.y * yScale})`;\n          }\n          return classString;\n        }\n      );\n\n    const oldLinks = this.g\n      .selectAll('path.link')\n      .data(tree.links()\n        .filter((d: any) => d.target.data.wrappedNodes[0].metadata.option !== 'merged'),\n        (d: any) => d.target.data.wrappedNodes.map((n: any) => n.id).join()\n      );\n\n    oldLinks.exit().remove();\n\n    const newLinks = oldLinks\n      .enter()\n      .insert('path', 'g')\n      .attr('d', (d: any) => this.linkPath(d));\n\n    oldLinks\n      .merge(newLinks as any)\n      .attr('class', 'link')\n      .filter((d: any) => d.target.x === 0)\n      .attr('class', 'link active');\n\n    oldLinks\n      .merge(newLinks as any)\n      .transition()\n      .duration(500)\n      .attr('d', (d: any) => this.linkPath(d));\n\n    const updatedLinks = oldLinks.merge(newLinks as any);\n    // console.log(\"--tree--\");\n    // console.log(tree);\n    // console.log(\"--newLinks--\");\n    // console.log(newLinks);\n    // console.log(\"--updateNodes--\");\n    // console.log(updateNodes);\n\n    if (this.caterpillarActivated) {\n      caterpillar(updateNodes, treeNodes, updatedLinks, this);\n    }\n  } // end update\n\n  public getTraverser(): ProvenanceGraphTraverser {\n    return this.traverser;\n  }\n}"],"names":["depthSort","d3.selectAll","d3.scaleOrdinal","d3.schemeAccent","d3.select","d3.zoom","d3.event","d3.zoomIdentity","d3.hierarchy","gratzl"],"mappings":"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"}