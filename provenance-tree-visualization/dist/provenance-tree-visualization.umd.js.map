{"version":3,"file":"provenance-tree-visualization.umd.js","sources":["../src/gratzl.ts","../src/controls.ts","../src/utils.ts","../src/aggregation/aggregation-implementations.ts","../src/aggregation/aggregation-objects.ts","../src/components.ts","../src/gratzl_old.ts","../src/caterpillar.ts","../src/provenance-tree-visualization.ts"],"sourcesContent":["import { HierarchyNode, HierarchyPointNode } from \"d3-hierarchy\";\r\n\r\nfunction depthSort(\r\n  a: IHierarchyPointNodeWithMaxDepth<any>,\r\n  b: IHierarchyPointNodeWithMaxDepth<any>\r\n) {\r\n  if (a.maxDescendantDepth > b.maxDescendantDepth) {\r\n    return -1;\r\n  } else if (a.maxDescendantDepth < b.maxDescendantDepth) {\r\n    return 1;\r\n  }\r\n  return 0;\r\n}\r\n\r\nexport interface IGratzlLayout<Datum> {\r\n  (\r\n    root: HierarchyNode<Datum>,\r\n    activeNode: HierarchyNode<Datum>\r\n  ): IHierarchyPointNodeWithMaxDepth<Datum>;\r\n  size(): [number, number];\r\n  size(size: [number, number]): this;\r\n}\r\n\r\nexport interface IHierarchyPointNodeWithMaxDepth<T>\r\n  extends HierarchyPointNode<T> {\r\n  maxDescendantDepth: number;\r\n  data: any;\r\n  // xOffset: number;\r\n  // x, y, links()\r\n}\r\n\r\nexport default function GratzlLayout<T>(\r\n  _root: HierarchyNode<T>,\r\n  _current: HierarchyNode<T>\r\n): IHierarchyPointNodeWithMaxDepth<T> {\r\n  const root = _root as IHierarchyPointNodeWithMaxDepth<T>;\r\n  const current = _current as IHierarchyPointNodeWithMaxDepth<T>;\r\n  const widths: number[] = [];\r\n  // const maxY = Math.max.apply(null, root.leaves().map((leaf) => leaf.depth));\r\n\r\n  function setTreeX(node: IHierarchyPointNodeWithMaxDepth<T>, val: number) {\r\n    node.x = val;\r\n    node.y = node.depth;\r\n    widths[node.depth] = val;\r\n    if (node.children) {\r\n      node\r\n        .leaves()\r\n        .forEach(leaf => {\r\n          if (typeof leaf.x === \"undefined\") {\r\n            const width = Math.max.apply(\r\n              null,\r\n              widths.slice(node.depth, leaf.depth + 1)\r\n            );\r\n            setTreeX(leaf, val > width ? val : width + 1);\r\n          }\r\n        });\r\n    }\r\n\r\n    if (node.parent && typeof node.parent.x === \"undefined\") {\r\n      setTreeX(node.parent, val);\r\n    }\r\n  }\r\n\r\n  root.leaves().forEach(leaf => {\r\n    leaf.ancestors().forEach(leafAncestor => {\r\n      if (\r\n        !leafAncestor.maxDescendantDepth ||\r\n        leaf.depth > leafAncestor.maxDescendantDepth\r\n      ) {\r\n        leafAncestor.maxDescendantDepth = leaf.depth;\r\n      }\r\n    });\r\n  });\r\n\r\n  /* start at the deepest (active) leaf of activeNode. */\r\n  let deepestLeaf = current;\r\n  deepestLeaf.leaves().forEach(leaf => {\r\n    if (leaf.data.wrappedNodes[0].metadata.mainbranch) {\r\n      deepestLeaf = leaf;\r\n    }\r\n    else if (leaf.depth > deepestLeaf.depth && !deepestLeaf.data.wrappedNodes[0].metadata.mainbranch) {\r\n      deepestLeaf = leaf;\r\n    }\r\n  });\r\n\r\n  setTreeX(deepestLeaf,0 );\r\n\r\n  return root;\r\n}\r\n","import { ProvenanceTreeVisualization } from './provenance-tree-visualization';\r\nimport { StateNode } from '@visualstorytelling/provenance-core';\r\n\r\n\r\nexport function provGraphControls(provenanceTreeVisualization: ProvenanceTreeVisualization) {\r\n    var graph = provenanceTreeVisualization.traverser.graph;\r\n    var traverser = provenanceTreeVisualization.traverser;\r\n    \r\n\r\n    window.onkeydown = keyPress;\r\n\r\n\r\n    function keyPress(e: any) {\r\n        var evtobj = window.event ? event : e;\r\n\r\n        // ctrl + Z  / undo\r\n        if (evtobj.ctrlKey && evtobj.key === 'z' && (graph.current as StateNode).parent) {\r\n            var real_traverser = provenanceTreeVisualization.real_traverser;\r\n            var parent_id = '';\r\n            real_traverser\r\n            .filter((d: any) => {\r\n              const ref = d.data.wrappedNodes.includes(graph.current);\r\n              if(ref){\r\n                parent_id = d.parent.data.wrappedNodes[0].id;\r\n              }\r\n            });\r\n            if(provenanceTreeVisualization.groupnumber == 0)\r\n                traverser.toStateNode(parent_id, 250);\r\n            else\r\n                traverser.toStateNode(parent_id, 0);\r\n            provenanceTreeVisualization.getFullsizeview();\r\n            provenanceTreeVisualization.update();\r\n        }\r\n        // ctrl + X  / go to the root\r\n        else if (evtobj.ctrlKey && evtobj.key === 'x') {\r\n            traverser.toStateNode(graph.root.id, 0);\r\n        }\r\n        // ctrl + y  / redo\r\n        else if (evtobj.ctrlKey && evtobj.key === 'y' && graph.current.children[0]) {\r\n            var real_traverser = provenanceTreeVisualization.real_traverser;\r\n            var child_id = '';\r\n            real_traverser\r\n            .filter((d: any) => {\r\n              const ref = d.data.wrappedNodes.includes(graph.current);\r\n              if(ref){\r\n                for(const child of d.children)\r\n                {\r\n                    if(child.data.wrappedNodes[0].metadata.mainbranch)\r\n                        child_id = child.data.wrappedNodes[0].id;\r\n                }\r\n                    \r\n              }\r\n            });\r\n            if(provenanceTreeVisualization.groupnumber == 0)\r\n                traverser.toStateNode(child_id, 250);\r\n            else\r\n                traverser.toStateNode(child_id, 0);\r\n            provenanceTreeVisualization.getFullsizeview();\r\n            provenanceTreeVisualization.update();\r\n        }\r\n        // ctrl + Q  / add the current node to the story\r\n        else if (evtobj.keyCode === 81 && evtobj.altKey) {\r\n            graph.current.metadata.story = true;\r\n            (window as any).slideDeck.onAdd(graph.current);\r\n        }\r\n        // // ctrl + 1  / all neighbour nodes are added to the slide deck (by creation order)\r\n        // else if (evtobj.keyCode === 49 && evtobj.altKey) {\r\n        //     let nodes = graph.getNodes();\r\n        //     var arrayNodes = [];\r\n\r\n        //     for (const nodeId of Object.keys(nodes)) {\r\n        //         let node = nodes[nodeId];\r\n        //         arrayNodes.push(node);\r\n        //     }\r\n\r\n        //     for (const node of arrayNodes) {\r\n        //         if (((node.metadata.creationOrder > graph.current.metadata.creationOrder - 2) == true) &&     // the range can be adjusted\r\n        //             ((node.metadata.creationOrder < graph.current.metadata.creationOrder + 2) == true)) {\r\n        //             node.metadata.story = true;\r\n        //             (window as any).slideDeck.onAdd(node);\r\n        //         }\r\n        //     }\r\n        // }\r\n\r\n        // // ctrl + W  / derivation and annotation (by creation order)\r\n        // else if (evtobj.keyCode === 87 && evtobj.altKey) {\r\n        //     let nodes = graph.getNodes();\r\n        //     var arrayNodes: any[] = [];\r\n\r\n        //     for (const nodeId of Object.keys(nodes)) {\r\n        //         let node = nodes[nodeId];\r\n        //         arrayNodes.push(node);\r\n        //     }\r\n\r\n        //     arrayNodes.shift();\r\n\r\n        //     for (const node of (arrayNodes as any).filter((node: any) => node.action.metadata.userIntent == 'derivation' || 'annotation')) {\r\n        //         node.metadata.story = true;\r\n        //         (window as any).slideDeck.onAdd(node);\r\n        //     }\r\n        // }\r\n        provenanceTreeVisualization.update();\r\n    }\r\n\r\n    // ngAfterViewChecked() {\r\n    //   this._viz.setZoomExtent();\r\n    // }\r\n\r\n    (function () {\r\n        var blockContextMenu;\r\n\r\n        blockContextMenu = function (evt: any) {\r\n            evt.preventDefault();\r\n        };\r\n\r\n        window.addEventListener('contextmenu', blockContextMenu);\r\n    })();\r\n\r\n}\r\n","export interface IGroupedTreeNode<T> {\r\n  children: Array<IGroupedTreeNode<T>>;\r\n  wrappedNodes: T[];\r\n  plotTrimmerValue: number;\r\n  camera: boolean;\r\n  neighbour: boolean;\r\n  bookmarked: boolean;\r\n}\r\n\r\nexport const copyTree = <T>(node: IGroupedTreeNode<T>): typeof node => {\r\n  return {\r\n    ...node,\r\n    children: node.children.map(copyTree)\r\n  };\r\n};\r\n\r\nexport const preOrderTraversal = <T>(\r\n  node: IGroupedTreeNode<T>,\r\n  cb: (n: typeof node) => any\r\n) => {\r\n  cb(node);\r\n  node.children.map(child => preOrderTraversal(child, cb));\r\n};\r\n\r\nexport type NodeGroupTest<T> = (\r\n  a: IGroupedTreeNode<T>,\r\n  b: IGroupedTreeNode<T>\r\n) => boolean;\r\n\r\nexport const group = <T>(node: IGroupedTreeNode<T>, test: NodeGroupTest<T>) => {\r\n  let merged = false;\r\n  do {\r\n    merged = false;\r\n    for (const child of node.children) {\r\n      if (test(node, child)) {\r\n        node.children.splice(node.children.indexOf(child), 1);\r\n        node.children.push(...child.children);\r\n        node.wrappedNodes.push(...child.wrappedNodes);\r\n        merged = true;\r\n        break;\r\n      }\r\n    }\r\n  } while (merged);\r\n  node.children.map(child => group(child, test));\r\n};\r\n\r\n\r\nexport const cam_test = <T>(label: any) => {\r\n  const searchpattern = /Camera|View/;\r\n  if(searchpattern.test(label))\r\n    return true;\r\n  else\r\n    return false;\r\n};","import { IGroupedTreeNode } from \"../utils\";\r\nimport {\r\n  ProvenanceNode,\r\n  isStateNode\r\n} from \"@visualstorytelling/provenance-core\";\r\n\r\n/**\r\n * @description Type for the tests for aggregating data.\r\n * @param a {IGroupedTreeNode<ProvenanceNode>} -\r\n * @param b {IGroupedTreeNode<ProvenanceNode>} -\r\n * @returns Returns true if the nodes has passed the test.\r\n */\r\nexport type NodeGroupTest<T> = (\r\n  a: IGroupedTreeNode<T>,\r\n  b: IGroupedTreeNode<T>\r\n) => boolean;\r\n\r\n/**\r\n * @description Type for the data aggregation algorithms\r\n * @param currentNode {IGroupedTreeNode<ProvenanceNode>} - Selected node.\r\n * @param node {IGroupedTreeNode<ProvenanceNode>} - Root of the tree.\r\n * @param test {NodeGroupTest<ProvenanceNode>} - Test to be executed.\r\n * @param mainBranch {Array<String>} - List of node's id which belong to the master branch.\r\n * @param par {any} - Optional parameter required for the algorithm\r\n */\r\nexport type NodeAggregationAlgorithm = (\r\n  currentNode: IGroupedTreeNode<ProvenanceNode>,\r\n  node: IGroupedTreeNode<ProvenanceNode>,\r\n  tests: NodeGroupTest<ProvenanceNode>[],\r\n  mainBranch?: Array<string>,\r\n  par?: any\r\n) => void;\r\n\r\n/**\r\n * @description Interface defines aggregation strategy.\r\n * @param name {string} - Name of the procedure\r\n * @param test {NodeGroupTest<ProvenanceNode>} - Test to be executed;\r\n * @param algorithm {NodeAggregationAlgorithm} - Algorithm to be performed;\r\n * @param arg {any} - Optional parameter if needed.\r\n * @param description {String} - Description of the procedure.\r\n */\r\nexport interface NodeAggregator<T> {\r\n  name: string;\r\n  tests: NodeGroupTest<T>[];\r\n  algorithm: NodeAggregationAlgorithm;\r\n  arg?: any;\r\n  description?: String;\r\n}\r\n\r\n/**\r\n * @description Child removed, child's children go to the parent.\r\n * @param node {IGroupedTreeNode<ProvenanceNode>} - Parent node\r\n * @param child {IGroupedTreeNode<ProvenanceNode>} - Child node\r\n */\r\nexport function transferToParent(\r\n  node: IGroupedTreeNode<ProvenanceNode>,\r\n  child: IGroupedTreeNode<ProvenanceNode>\r\n) {\r\n  const index = node.children.indexOf(child);\r\n  node.children.splice(index, 1);\r\n  node.children.push(...child.children);\r\n  node.wrappedNodes.unshift(...child.wrappedNodes);\r\n}\r\n\r\n/**\r\n * @description Child removed, child's children go to grandChild. GrandChild becomes node's child.\r\n * @param node {IGroupedTreeNode<ProvenanceNode>} - Parent node\r\n * @param child {IGroupedTreeNode<ProvenanceNode>} - Child node\r\n * @param grandChild {IGroupedTreeNode<ProvenanceNode>} - Child of the child node\r\n */\r\nexport function transferChildren(\r\n  node: any,\r\n  child: any,\r\n  grandChild: any\r\n) {\r\n  //data part\r\n  node.children.splice(node.children.indexOf(child), 1);\r\n  child.children.splice(child.children.indexOf(grandChild), 1);\r\n  grandChild.wrappedNodes.push(...child.wrappedNodes);\r\n  node.children.push(grandChild);\r\n}\r\nexport function transferChildren_2(\r\n  Startparentnode: any,\r\n  Startnode: any,\r\n  Endnode: any\r\n) {\r\n  //data part\r\n  let tempNode = Endnode.parent;\r\n  let superParent = Startparentnode.parent;\r\n  do{\r\n    tempNode.data.children.splice(tempNode.children[0]);\r\n    Endnode.data.wrappedNodes.push(...tempNode.data.wrappedNodes);\r\n    tempNode = tempNode.parent;\r\n  }while(tempNode.data != Startparentnode.data)\r\n  Startparentnode.data.children.splice(Startparentnode.children.indexOf(Startnode), 1);\r\n  Endnode.data.wrappedNodes.push(...Startparentnode.data.wrappedNodes);\r\n  superParent.data.children.splice(superParent.children.indexOf(Startparentnode), 1);\r\n  superParent.data.children.push(Endnode.data);\r\n}\r\n\r\n/**\r\n * @description Pointed node wraps ALL children recursively\r\n * @param node {IGroupedTreeNode<ProvenanceNode>} - Selected node\r\n */\r\nexport function transferAll(node: IGroupedTreeNode<ProvenanceNode>) {\r\n  let done: boolean;\r\n  do {\r\n    done = false;\r\n    if (node.children) {\r\n      for (const child of node.children) {\r\n        transferToParent(node, child);\r\n        done = true;\r\n      }\r\n    }\r\n  } while (done);\r\n}\r\n\r\n/**\r\n * @description Test whether a node should be constrained based on the currently selected node.\r\n * @param  node  {IGroupedTreeNode<ProvenanceNode>} - The node to test.\r\n * @param  node  {IGroupedTreeNode<ProvenanceNode>} - Currently selected node.\r\n */\r\nexport function shouldConstrain(\r\n  node: IGroupedTreeNode<ProvenanceNode>,\r\n  selectedNode: IGroupedTreeNode<ProvenanceNode>\r\n): boolean {\r\n  let result = false;\r\n  const rawNode = node.wrappedNodes[0];\r\n\r\n  if (node === selectedNode || rawNode.metadata.bookmarked) {\r\n    result = true;\r\n  } else if (node.children.includes(selectedNode)) {\r\n    result = true;\r\n  } else if (selectedNode.children.includes(node)) {\r\n    result = true;\r\n  }\r\n\r\n  return result;\r\n}\r\n\r\n/**\r\n * @description Test whether a node is a leaf node.\r\n * @param  node  {IGroupedTreeNode<ProvenanceNode>} - The node to test.\r\n */\r\nexport function isLeafNode(node: IGroupedTreeNode<ProvenanceNode>): boolean {\r\n  let result = false;\r\n\r\n  if (node.children.length === 0) {\r\n    result = true;\r\n  }\r\n\r\n  return result;\r\n}\r\n\r\n/**\r\n * @description Test whether a node is an interval node.\r\n * @param  node  {IGroupedTreeNode<ProvenanceNode>} - The node to test.\r\n */\r\nexport function isIntervalNode(\r\n  node: IGroupedTreeNode<ProvenanceNode>\r\n): boolean {\r\n  let result = false;\r\n\r\n  if (node.children.length === 1) {\r\n    result = true;\r\n  }\r\n\r\n  return result;\r\n}\r\n\r\n/**\r\n * @description Test whether two nodes are neighbours.\r\n * @param  a  {IGroupedTreeNode<ProvenanceNode>} - The first node to test.\r\n * @param  b  {IGroupedTreeNode<ProvenanceNode>} - The second node to test.\r\n */\r\nexport function areNeighbours(\r\n  a: IGroupedTreeNode<ProvenanceNode>,\r\n  b: IGroupedTreeNode<ProvenanceNode>\r\n): boolean {\r\n  let result = false;\r\n\r\n  if (b.children.includes(a)) {\r\n    result = true;\r\n  } else if (a.children.includes(b)) {\r\n    result = true;\r\n  }\r\n\r\n  return result;\r\n}\r\n\r\n/**\r\n * @description Calculate the distance of this node to any node in the main (selected) branch.\r\n * @param  node  {IGroupedTreeNode<ProvenanceNode>} - The node to test.\r\n * @param  mainBranch  {Array<string>} - List of node ids which belong to the master branch.\r\n */\r\nexport function distanceToMainBranch(\r\n  node: ProvenanceNode,\r\n  mainBranch: Array<string> | undefined\r\n): number {\r\n  let result = 0;\r\n\r\n  if (mainBranch === undefined) {\r\n    result = 0;\r\n  } else if (isStateNode(node) && mainBranch.includes(node.id)) {\r\n    result = 0;\r\n  } else {\r\n    if (isStateNode(node)) {\r\n      result = 1 + distanceToMainBranch(node.parent, mainBranch);\r\n    }\r\n  }\r\n\r\n  return result;\r\n}\r\n\r\n/**\r\n * @description Returns the minimum depth possible from the node selected.\r\n * @param node {IGroupedTreeNode<ProvenanceNode>} - Selected node\r\n * @returns Number of nodes you have to cross to go to the deepest leaf from the node selected.\r\n */\r\nexport const minDepth = <T>(node: IGroupedTreeNode<T>): number => {\r\n  if (node.children.length === 0) {\r\n    return 0;\r\n  }\r\n  return Math.min(...node.children.map(minDepth)) + 1;\r\n};\r\n\r\n/**\r\n * @description Returns the maximum depth possible from the node selected.\r\n * @param node {IGroupedTreeNode<ProvenanceNode>} - Selected node\r\n * @returns Number of nodes you have to cross to go to the deepest leaf from the node selected.\r\n */\r\nexport const maxDepth = <T>(node: IGroupedTreeNode<T>): number => {\r\n  if (node.children.length === 0) {\r\n    return 1;\r\n  }\r\n  return Math.max(...node.children.map(maxDepth)) + 1;\r\n};\r\n\r\n/**\r\n * @description Returns the distance to the subroot from the node selected.\r\n * @param provNode {ProvenanceNode} - Selected node\r\n * @returns Number of nodes you have to cross to go to the subroot up from the node selected.\r\n */\r\nexport const subrootDist = (provNode: ProvenanceNode): number => {\r\n  let value = 0;\r\n\r\n  if (!isStateNode(provNode)) {\r\n    value = 0;\r\n  } else if (isStateNode(provNode)) {\r\n    if (provNode.parent.children.length > 1) {\r\n      value = 1;\r\n    } else {\r\n      value = 1 + subrootDist(provNode.parent);\r\n    }\r\n  }\r\n  return value;\r\n};\r\n\r\n/**\r\n * @description Returns the number of conexions with the node selected.\r\n * @param node {IGroupedTreeNode<ProvenanceNode>} - Selected node\r\n * @returns Number of nodes you have to cross to go to the deepest leaf from the node selected.\r\n */\r\nexport const connectivity = (node: IGroupedTreeNode<ProvenanceNode>) => {\r\n  return 1 + node.children.length;\r\n};\r\n\r\n/**\r\n * @description Return the first node found in nodes that also belongs to the main branch of the tree.\r\n * @param  mainBranch  {Array<string>} - List of node ids which belong to the master branch.\r\n * @param  nodes  {Array<IGroupedTreeNode<ProvenanceNode>>} - List of nodes to test.\r\n */\r\nconst mainNode = (\r\n  mainBranch: Array<string>,\r\n  nodes: Array<IGroupedTreeNode<ProvenanceNode>>\r\n): IGroupedTreeNode<ProvenanceNode> | undefined => {\r\n  let mNode;\r\n  for (const node of nodes) {\r\n    if (mainBranch.includes(node.wrappedNodes[0].id)) {\r\n      mNode = node;\r\n      break;\r\n    }\r\n  }\r\n  return mNode;\r\n};\r\n\r\n/**\r\n * @description Compare the depth of two selected nodes.\r\n * @param  node1  {IGroupedTreeNode<ProvenanceNode>} - Selected node #1\r\n * @param  node2  {IGroupedTreeNode<ProvenanceNode>} - Selected node #2\r\n */\r\nconst nodeDepthComparison = <T>(\r\n  node1: IGroupedTreeNode<T>,\r\n  node2: IGroupedTreeNode<T>\r\n): number => {\r\n  if (maxDepth(node1) > maxDepth(node2)) {\r\n    return 1;\r\n  } else if (maxDepth(node1) < maxDepth(node2)) {\r\n    return -1;\r\n  }\r\n  return 0;\r\n};\r\n\r\nconst mergemarking = () => {\r\n\r\n};\r\n\r\n/**\r\n * @description Test everything.\r\n * @param tests {Array<NodeGroupTest<ProvenanceNode>>} - The tests to run\r\n * @param  node1  {IGroupedTreeNode<ProvenanceNode>} - Selected node #1\r\n * @param  node2  {IGroupedTreeNode<ProvenanceNode>} - Selected node #2\r\n * @returns true only if all tests return true\r\n */\r\nconst testAll = (\r\n  tests: Array<NodeGroupTest<ProvenanceNode>>,\r\n  node1: IGroupedTreeNode<ProvenanceNode>,\r\n  node2: IGroupedTreeNode<ProvenanceNode>\r\n): boolean => {\r\n  let result = true;\r\n\r\n  for (const test of tests) {\r\n    result = test(node1, node2);\r\n    if (!result) {\r\n      break;\r\n    }\r\n  }\r\n\r\n  return result;\r\n};\r\n\r\n// /**\r\n//  * @description Constrain neighbours\r\n//  * @param node {IGroupedTreeNode<ProvenanceNode>} - Node\r\n//  * @param selectedNode {IGroupedTreeNode<ProvenanceNode>} - Selected node\r\n//  */\r\n// export const neighbours = (node: IGroupedTreeNode<ProvenanceNode>, selectedNode: IGroupedTreeNode<ProvenanceNode>) => {\r\n//   let neighbour = false;\r\n\r\n//   if (node === selectedNode || selectedNode.children.includes(node) || node.children.includes(selectedNode)) {\r\n//     neighbour = true;\r\n//   }\r\n\r\n//   node.neighbour = neighbour;\r\n\r\n//   for (const child of node.children) {\r\n//     neighbours(child, selectedNode);\r\n//   }\r\n// };\r\n\r\n/////////////////// DIFFERENT DATA AGGREGATION ALGORITHM ///////////\r\n/**\r\n * @description No algorithm is applied. Created for a better understanding.\r\n * @param  node  {IGroupedTreeNode<ProvenanceNode>} - Root of the graph\r\n * @param  tests  {Array<NodeGroupTest<ProvenanceNode>>} - Test to be checked during execution.\r\n * @param  currentNode  {IGroupedTreeNode<ProvenanceNode>} -\r\n */\r\nexport const doNothing: NodeAggregationAlgorithm = (\r\n  currentNode: IGroupedTreeNode<ProvenanceNode>,\r\n  node: IGroupedTreeNode<ProvenanceNode>,\r\n  tests: NodeGroupTest<ProvenanceNode>[]\r\n) => { };\r\n\r\n/**\r\n * @param  node  {IGroupedTreeNode<ProvenanceNode>} - Root of the graph\r\n * @param  tests  {Array<NodeGroupTest<ProvenanceNode>>} - Tests to be checked during execution.\r\n */\r\nexport const group: NodeAggregationAlgorithm = (\r\n  currentNode: IGroupedTreeNode<ProvenanceNode>,\r\n  node: IGroupedTreeNode<ProvenanceNode>,\r\n  tests: NodeGroupTest<ProvenanceNode>[]\r\n) => {\r\n  let merged = false;\r\n  do {\r\n    merged = false;\r\n    for (const child of node.children) {\r\n      if (!shouldConstrain(child, currentNode)) {\r\n        for (const grandChild of child.children) {\r\n          if (testAll(tests, child, grandChild)) {\r\n            transferChildren(node, child, grandChild);\r\n            merged = true;\r\n            break;\r\n          }\r\n        }\r\n        if (merged) {\r\n          break;\r\n        }\r\n      }\r\n    }\r\n  } while (merged);\r\n  node.children.map(child => group(currentNode, child, tests));\r\n};\r\n\r\n/**\r\n * @param  node  {IGroupedTreeNode<ProvenanceNode>} - Root of the graph\r\n * @param  tests  {Array<NodeGroupTest<ProvenanceNode>>} - Tests to be checked during execution.\r\n */\r\nexport const compress: NodeAggregationAlgorithm = (\r\n  currentNode: IGroupedTreeNode<ProvenanceNode>,\r\n  node: IGroupedTreeNode<ProvenanceNode>,\r\n  tests: NodeGroupTest<ProvenanceNode>[]\r\n) => {\r\n  let merged = false;\r\n  do {\r\n    merged = false;\r\n    for (const child of node.children) {\r\n      if (!shouldConstrain(child, currentNode)) {\r\n        if (testAll(tests, node, child)) {\r\n          transferToParent(node, child);\r\n          merged = true;\r\n          break;\r\n        }\r\n      }\r\n    }\r\n  } while (merged);\r\n  node.children.map(child => compress(currentNode, child, tests));\r\n};\r\n\r\n/**\r\n * @param  node  {IGroupedTreeNode<ProvenanceNode>} - Root of the graph\r\n * @param  tests  {Array<NodeGroupTest<ProvenanceNode>>} - Tests to be checked during execution.\r\n * @param mainBranch {Array<string>} - List of node's id which belong to the master branch.\r\n * @param arg {any} - Optinal parameter\r\n */\r\nexport const prune: NodeAggregationAlgorithm = (\r\n  currentNode: IGroupedTreeNode<ProvenanceNode>,\r\n  node: IGroupedTreeNode<ProvenanceNode>,\r\n  tests: NodeGroupTest<ProvenanceNode>[],\r\n  mainBranch: Array<string> | undefined,\r\n  arg: any\r\n) => {\r\n  const parameter: number = +arg;\r\n  let merged = false;\r\n\r\n  do {\r\n    merged = false;\r\n    const p = arg;\r\n\r\n    for (const child of node.children) {\r\n      if (!shouldConstrain(child, currentNode)) {\r\n        const dist = distanceToMainBranch(child.wrappedNodes[0], mainBranch);\r\n        if (isLeafNode(child)) {\r\n          if (dist <= p) {\r\n            transferToParent(node, child);\r\n            merged = true;\r\n          }\r\n        } else {\r\n          for (const grandChild of child.children) {\r\n            if (\r\n              !shouldConstrain(grandChild, currentNode) &&\r\n              distanceToMainBranch(child.wrappedNodes[0], mainBranch) > 0\r\n            ) {\r\n              const childDepth = maxDepth(child);\r\n              if (dist + childDepth <= p) {\r\n                transferChildren(node, child, grandChild);\r\n                merged = true;\r\n              }\r\n            }\r\n          }\r\n        }\r\n      }\r\n    }\r\n  } while (merged);\r\n  node.children.map(child =>\r\n    prune(currentNode, child, tests, mainBranch, parameter)\r\n  );\r\n};\r\n\r\n/**\r\n * @param  node  {IGroupedTreeNode<ProvenanceNode>} - Root of the graph\r\n * @param  tests  {Array<NodeGroupTest<ProvenanceNode>>} - Test to be checked during execution.\r\n * @param arg {any} - Optinal parameter\r\n */\r\nexport const plotTrimmerFunc: NodeAggregationAlgorithm = (\r\n  currentNode: IGroupedTreeNode<ProvenanceNode>,\r\n  node: IGroupedTreeNode<ProvenanceNode>,\r\n  tests: NodeGroupTest<ProvenanceNode>[],\r\n  mainBranch: Array<string> | undefined,\r\n  arg: any\r\n) => {\r\n  trimmer(currentNode, node, tests, mainBranch, arg);\r\n};\r\nexport const trimmerAssignValues = (node: IGroupedTreeNode<ProvenanceNode>) => {\r\n  // Leaf value = subroot distance * 2\r\n  // Interval nodes value = 1\r\n  // Subroots value = Minimum subroot distance of children * 2 + 1\r\n  let value = 0;\r\n\r\n  if (!isStateNode(node.wrappedNodes[0]) === null) {\r\n    value = Number.MAX_VALUE;\r\n  } else if (connectivity(node) === 1) {\r\n    // Leaf node\r\n    value = subrootDist(node.wrappedNodes[0]) * 2;\r\n  } else if (connectivity(node) === 2) {\r\n    // Interval node\r\n    value = 1;\r\n  } else {\r\n    // Subroot\r\n    value = minDepth(node) * 2 + 1;\r\n  }\r\n\r\n  node.plotTrimmerValue = value;\r\n\r\n  for (const child of node.children) {\r\n    trimmerAssignValues(child);\r\n  }\r\n};\r\n\r\n/**\r\n * @param  node  {IGroupedTreeNode<ProvenanceNode>} - Root of the graph\r\n * @param  tests  {Array<NodeGroupTest<ProvenanceNode>>} - Test to be checked during execution.\r\n * @param arg {any} - Optinal parameter\r\n */\r\nconst trimmer: NodeAggregationAlgorithm = (\r\n  currentNode: IGroupedTreeNode<ProvenanceNode>,\r\n  node: IGroupedTreeNode<ProvenanceNode>,\r\n  tests: NodeGroupTest<ProvenanceNode>[],\r\n  mainBranch: Array<string> | undefined,\r\n  arg: any\r\n) => {\r\n  const parameter: number = +arg;\r\n  let merged: boolean;\r\n\r\n  trimmerAssignValues(node);\r\n\r\n  do {\r\n    merged = false;\r\n\r\n    for (const child of node.children) {\r\n      if (!shouldConstrain(child, currentNode)) {\r\n        if (parameter >= child.plotTrimmerValue) {\r\n          transferToParent(node, child);\r\n          merged = true;\r\n        }\r\n      }\r\n    }\r\n  } while (merged);\r\n  node.children.map(child =>\r\n    trimmer(currentNode, child, tests, mainBranch, parameter)\r\n  );\r\n};\r\n\r\n/**\r\n * @param  node  {IGroupedTreeNode<ProvenanceNode>} - Root of the graph\r\n * @param  test  {IGroupedTreeNode<ProvenanceNode>} - Test to be checked during execution.\r\n * @param arg {any} - Optinal parameter\r\n */\r\nexport const plotTrimmerFuncG: NodeAggregationAlgorithm = (\r\n  currentNode: IGroupedTreeNode<ProvenanceNode>,\r\n  node: IGroupedTreeNode<ProvenanceNode>,\r\n  tests: NodeGroupTest<ProvenanceNode>[],\r\n  mainBranch: Array<string> | undefined,\r\n  arg: any\r\n) => {\r\n  const parameter = +arg;\r\n  let prunePar = 0;\r\n\r\n  for (let i = 0; i <= parameter; i++) {\r\n    if (i % 2 === 0 && i !== 0) {\r\n      prunePar = prunePar + 1;\r\n      prune(currentNode, node, tests, mainBranch, prunePar);\r\n    } else {\r\n      group(currentNode, node, tests);\r\n    }\r\n  }\r\n};\r\n\r\n/**\r\n * @param  node  {IGroupedTreeNode<ProvenanceNode>} - Root of the graph\r\n * @param  test  {IGroupedTreeNode<ProvenanceNode>} - Test to be checked during execution.\r\n * @param arg {any} - Optinal parameter\r\n */\r\nexport const plotTrimmerFuncC: NodeAggregationAlgorithm = (\r\n  currentNode: IGroupedTreeNode<ProvenanceNode>,\r\n  node: IGroupedTreeNode<ProvenanceNode>,\r\n  tests: NodeGroupTest<ProvenanceNode>[],\r\n  mainBranch: Array<string> | undefined,\r\n  arg: any\r\n) => {\r\n  const parameter = +arg;\r\n  let prunePar = 0;\r\n\r\n  for (let i = 0; i <= parameter; i++) {\r\n    if (i % 2 === 0 && i !== 0) {\r\n      prunePar = prunePar + 1;\r\n      prune(currentNode, node, tests, mainBranch, prunePar);\r\n    } else {\r\n      compress(currentNode, node, tests);\r\n    }\r\n  }\r\n};\r\n","import {\r\n  compress,\r\n  NodeAggregator,\r\n  doNothing,\r\n  group,\r\n  NodeGroupTest,\r\n  plotTrimmerFunc,\r\n  prune,\r\n  areNeighbours,\r\n  plotTrimmerFuncC,\r\n  plotTrimmerFuncG\r\n} from \"./aggregation-implementations\";\r\nimport {\r\n  ProvenanceNode,\r\n  isStateNode\r\n} from \"@visualstorytelling/provenance-core\";\r\nimport { IGroupedTreeNode } from \"../utils\";\r\n\r\n/**\r\n * @description Getter for the user intent of the node selected.\r\n * @param  node  {IGroupedTreeNode<ProvenanceNode>} - Node selected.\r\n * @returns Returns the Intent of the user for the node selected.\r\n */\r\nexport function getNodeIntent(node: ProvenanceNode): string {\r\n  if (\r\n    isStateNode(node) &&\r\n    node.action &&\r\n    node.action.metadata &&\r\n    node.action.metadata.userIntent\r\n  ) {\r\n    return node.action.metadata.userIntent;\r\n  }\r\n  return \"none\";\r\n}\r\n\r\nexport function getNodeRenderer(node: ProvenanceNode): string {\r\n  if (\r\n    isStateNode(node) &&\r\n    node.action &&\r\n    node.action.metadata &&\r\n    node.action.metadata.renderer\r\n  ) {\r\n    return node.action.metadata.renderer;\r\n  }\r\n  return \"none\";\r\n}\r\n\r\n/**\r\n * @description Test whether a node is a key node or not.\r\n * @param  node  {IGroupedTreeNode<ProvenanceNode>} - Node selected.\r\n */\r\nexport function isKeyNode(node: ProvenanceNode): boolean {\r\n  if (\r\n    !isStateNode(node) ||\r\n    node.children.length === 0 ||\r\n    node.children.length > 1 ||\r\n    node.parent.children.length > 1 ||\r\n    (node.children.length === 1 &&\r\n      getNodeIntent(node) !== getNodeIntent(node.children[0]))\r\n  ) {\r\n    return true;\r\n  }\r\n  return false;\r\n}\r\n\r\n/**\r\n * @description Returns a label for grouped nodes.\r\n * @param  node  {IGroupedTreeNode<ProvenanceNode>} - Node selected.\r\n */\r\nexport const groupNodeLabel = (node: IGroupedTreeNode<ProvenanceNode>) => {\r\n  if (node.wrappedNodes.length === 1) {\r\n    return node.wrappedNodes[0].label;\r\n  } \r\n  else {\r\n    const label_arr =node.wrappedNodes.map(n => n.label);\r\n    const unique_label_arr = new Set(label_arr);\r\n    if(unique_label_arr.size === 1)//all labels are the same\r\n      return node.wrappedNodes[0].label;\r\n    else{ // labels are different\r\n      let label = \"\";\r\n      const searchpattern = /Camera|View/;\r\n      const searchpattern_2 = /Object/;\r\n      const searchpattern_3 = /Annotation/;\r\n      const searchpattern_4 = /Measure/;\r\n      for (let u_label of unique_label_arr.values()) {\r\n        if(searchpattern.test(u_label) && label.search('Camera') === -1)\r\n          label = label + \"Camera,\";\r\n        else if(searchpattern_2.test(u_label) && label.search('Object') === -1)\r\n          label = label + \"Object,\";\r\n        else if(searchpattern_3.test(u_label) && label.search('Annotation') === -1)\r\n          label = label + \"Annotation,\";\r\n        else if(searchpattern_4.test(u_label) && label.search('Measure') === -1)\r\n          label = label + \"Measure,\";\r\n      }\r\n      label = label.slice(0, -1);\r\n      return label;\r\n\r\n    }\r\n  }\r\n};\r\n\r\n/**\r\n * @description Wraps a node and its children recursively\r\n * in an extra IGroupedTreeNode; which can be manipulated for grouping etc,\r\n * without modifying the (provenance) node.\r\n * @param  node  {IGroupedTreeNode<ProvenanceNode>} - Node selected.\r\n */\r\nexport const wrapNode = (\r\n  node: ProvenanceNode\r\n): IGroupedTreeNode<ProvenanceNode> => {\r\n  const searchpattern = /Camera|View/;\r\n  if(searchpattern.test(node.label))\r\n    return {\r\n      wrappedNodes: [node],\r\n      children: node.children.map(wrapNode),\r\n      plotTrimmerValue: -1,\r\n      neighbour: false,\r\n      bookmarked: false,\r\n      camera: true\r\n    };\r\n  else\r\n    return {\r\n      wrappedNodes: [node],\r\n      children: node.children.map(wrapNode),\r\n      plotTrimmerValue: -1,\r\n      neighbour: false,\r\n      bookmarked: false,\r\n      camera: false\r\n    };\r\n};\r\n\r\n/**\r\n * @description Test placeholder.\r\n * @param a {IGroupedTreeNode<ProvenanceNode>} - Node #1 to be tested.\r\n * @param b {IGroupedTreeNode<ProvenanceNode>} - Node #2 to be tested.\r\n */\r\nexport const testNothing: NodeGroupTest<ProvenanceNode> = (\r\n  a: IGroupedTreeNode<ProvenanceNode>,\r\n  b: IGroupedTreeNode<ProvenanceNode>\r\n) => false;\r\n\r\n/**\r\n * @description Test if two nodes share the same userIntent.\r\n * @param a {IGroupedTreeNode<ProvenanceNode>} - Node #1 to be tested.\r\n * @param b {IGroupedTreeNode<ProvenanceNode>} - Node #2 to be tested.\r\n */\r\nexport const testUserIntent: NodeGroupTest<ProvenanceNode> = (\r\n  a: IGroupedTreeNode<ProvenanceNode>,\r\n  b: IGroupedTreeNode<ProvenanceNode>\r\n) => getNodeIntent(a.wrappedNodes[0]) === getNodeIntent(b.wrappedNodes[0]);\r\n\r\n/**\r\n * @description Test if b is an interval node.\r\n * @param a {IGroupedTreeNode<ProvenanceNode>} - Not used.\r\n * @param b {IGroupedTreeNode<ProvenanceNode>} - Node to be tested.\r\n */\r\nexport const testIsIntervalNode: NodeGroupTest<ProvenanceNode> = (\r\n  a: IGroupedTreeNode<ProvenanceNode>,\r\n  b: IGroupedTreeNode<ProvenanceNode>\r\n) => b.children.length === 1;\r\n\r\n/**\r\n * @description Test if a and b are neighbours.\r\n * @param a {IGroupedTreeNode<ProvenanceNode>} - Node #1 to be tested.\r\n * @param b {IGroupedTreeNode<ProvenanceNode>} - Node #2 to be tested.\r\n */\r\nexport const testNeighbours: NodeGroupTest<ProvenanceNode> = (\r\n  a: IGroupedTreeNode<ProvenanceNode>,\r\n  b: IGroupedTreeNode<ProvenanceNode>\r\n) => areNeighbours(a, b);\r\n\r\n//////// Objects that represent the different data aggregation algorithms///////////\r\n\r\n/**Default Option as Raw Data */\r\nexport const defaultData: NodeAggregator<ProvenanceNode> = {\r\n  name: \"Select Aggregation\",\r\n  tests: [testNothing],\r\n  algorithm: doNothing,\r\n  arg: false,\r\n  description: \"No algorithm is applied. The full provenance data is shown.\"\r\n};\r\n/**\r\n * @description Object of the interface DataAggregation<ProvenanceNode>.\r\n */\r\nexport const rawData: NodeAggregator<ProvenanceNode> = {\r\n  name: \"Raw data\",\r\n  tests: [testNothing],\r\n  algorithm: doNothing,\r\n  arg: false,\r\n  description: \"No algorithm is applied. The full provenance data is shown.\"\r\n};\r\n\r\n/**\r\n * @description Object of the interface DataAggregation<ProvenanceNode>.\r\n */\r\nexport const grouping: NodeAggregator<ProvenanceNode> = {\r\n  name: \"Grouping\",\r\n  tests: [testUserIntent, testIsIntervalNode],\r\n  algorithm: group,\r\n  arg: false,\r\n  description: `This algorithm groups nodes of the same category (color).\r\nThe remaining nodes represent the last interactions of category groups.\r\nThe grouped nodes must have connectivity equal to two or less (interval nodes or leaves) and must belong to the same category group.`\r\n};\r\n\r\n/**\r\n * @description Object of the interface DataAggregation<ProvenanceNode>.\r\n */\r\nexport const compression: NodeAggregator<ProvenanceNode> = {\r\n  name: \"Compression\",\r\n  tests: [testIsIntervalNode, testIsIntervalNode],\r\n  algorithm: compress,\r\n  arg: false,\r\n  description: `This algorithm groups nodes with connectivity equals to two (interval nodes). However,\r\nthe node which 'absorbs' the grouped nodes and which is still visualized can be of any connectivity\r\nThe remaining nodes are nodes with connectivity different to two (leaves or subroots).\r\nThe nodes are grouped regardless their category.`\r\n};\r\n\r\n/**\r\n * @description Object of the interface DataAggregation<ProvenanceNode>.\r\n */\r\nexport const pruning: NodeAggregator<ProvenanceNode> = {\r\n  name: \"Pruning\",\r\n  tests: [testIsIntervalNode],\r\n  algorithm: prune,\r\n  arg: true,\r\n  description: `This algorithm groups nodes with connectivity equals to two (interval nodes), regardless their category.\r\nA chosen parameter indicates the minimum height that a subtree must have to be shown.\r\nE.g., if the chosen parameter is two, the subtrees with height two or less than two will be grouped.\r\nThe grouped subtrees are represented by their subroot.\r\nThe main tree is not considered as a subtree.`\r\n};\r\n\r\n/**\r\n * @description Object of the interface DataAggregation<ProvenanceNode>.\r\n */\r\nexport const plotTrimmer: NodeAggregator<ProvenanceNode> = {\r\n  name: \"PlotTrimmer\",\r\n  tests: [testIsIntervalNode],\r\n  algorithm: plotTrimmerFunc,\r\n  arg: true,\r\n  description: \"Lorem Ipsum\"\r\n};\r\n\r\n/**\r\n * @description Object of the interface DataAggregation<ProvenanceNode>.\r\n */\r\nexport const plotTrimmerC: NodeAggregator<ProvenanceNode> = {\r\n  name: \"PlotTrimmer C\",\r\n  tests: [testIsIntervalNode],\r\n  algorithm: plotTrimmerFuncC,\r\n  arg: true,\r\n  description: \"Lorem Ipsum\"\r\n};\r\n\r\n/**\r\n * @description Object of the interface DataAggregation<ProvenanceNode>.\r\n */\r\nexport const plotTrimmerG: NodeAggregator<ProvenanceNode> = {\r\n  name: \"PlotTrimmer G\",\r\n  tests: [testIsIntervalNode],\r\n  algorithm: plotTrimmerFuncG,\r\n  arg: true,\r\n  description: \"Lorem Ipsum\"\r\n};\r\n\r\n/**\r\n * @description List of the data aggregation objects. Whenever you want to add a\r\n * new data aggregation algorithm: create object and add it to this list.\r\n */\r\n\r\nexport const aggregationObjects = [\r\n  defaultData,\r\n  rawData,\r\n  grouping,\r\n  compression,\r\n  pruning,\r\n  plotTrimmer,\r\n  plotTrimmerC,\r\n  plotTrimmerG\r\n];\r\n\r\nexport const aggregationObjectsUI1 = [\r\n  defaultData,\r\n  rawData,\r\n  plotTrimmerG\r\n];\r\nexport const aggregationObjectsUI2 = [\r\n  defaultData,\r\n  rawData,\r\n  plotTrimmerC\r\n];","import * as d3 from 'd3';\r\nimport { ProvenanceTreeVisualization } from './provenance-tree-visualization';\r\n// import { addLegend, addCommandsList, addTasksList } from './legend';\r\nimport { StateNode } from '@visualstorytelling/provenance-core';\r\n\r\n/**\r\n * @description Show the title of the data aggregation algorithm used.\r\n */\r\nexport type HTMLDivSelection = d3.Selection<\r\n  HTMLDivElement,\r\n  unknown,\r\n  null,\r\n  undefined\r\n>;\r\nexport function setTitle(elm: HTMLDivSelection, onClick: () => any) {\r\n  elm\r\n    .append('div')\r\n    .attr('id', 'DataAggregationTitle')\r\n    .attr('style', 'text-align: center;')\r\n    .append('text')\r\n    .attr('class', 'titleAggregation')\r\n    .attr('id', 'DataAggregation')\r\n    .text('Raw Data')\r\n    .on('click', onClick)\r\n    .attr('style', 'cursor:pointer');\r\n}\r\n\r\n/**\r\n * @description Show the buttons of the user interface.\r\n */\r\nexport function addAggregationButtons(\r\n  elm: HTMLDivSelection,\r\n  provenanceTreeVisualization: ProvenanceTreeVisualization\r\n) {\r\n  const container = elm.append('div').attr('class', 'container');\r\n\r\n  // const holder = provenanceTreeVisualization.container\r\n  //   .append(\"div\")\r\n  //   .attr(\"class\", \"holder\")\r\n  //   .attr(\"id\", \"groupingContainer\")\r\n  //   .attr(\"style\", \"position: absolute; bottom: 25%; display:none;\");\r\n\r\n  \r\n  const goToTheRootButton = provenanceTreeVisualization.container\r\n    .append('button')\r\n    .attr('id', 'root-trigger')\r\n    .attr('class', 'mat-icon-button mat-button-base mat-primary')\r\n    .attr('color', 'primary')\r\n    .attr('title', 'Show the full provenance tree')\r\n    .attr('style', 'position: absolute; z-index: 1; top: 2%;')\r\n    .attr('ng-reflect-color', 'primary')\r\n    .on('mousedown', () => {\r\n      if (provenanceTreeVisualization.traverser.graph.root) {\r\n        provenanceTreeVisualization.getFullsizeview();\r\n      }\r\n    });\r\n\r\n  goToTheRootButton\r\n    .append('span')\r\n    .attr('class', 'mat-button-wrapper')\r\n    .append('mat-icon')\r\n    .attr('class', 'mat-icon notranslate material-icons mat-icon-no-color')\r\n    .attr('role', 'img')\r\n    .attr('aria-hidden', 'true')\r\n    .text('radio_button_unchecked');\r\n\r\n  goToTheRootButton\r\n    .append('div')\r\n    .attr('class', 'mat-button-ripple mat-ripple mat-button-ripple-round')\r\n    .attr('ng-reflect-centered', 'true')\r\n    .attr('ng-reflect-disabled', 'false')\r\n    .attr('ng-reflect-trigger', '[object HTMLButtonElement]');\r\n\r\n  goToTheRootButton\r\n    .append('div')\r\n    .attr('class', 'mat-button-focus-overlay');\r\n\r\n\r\n\r\nconst upwardButton = provenanceTreeVisualization.container\r\n  .append('button')\r\n  .attr('id', 'upward-trigger')\r\n  .attr('title', 'Move Up One Node')\r\n  .attr('class', 'mat-icon-button mat-button-base mat-primary')\r\n  .attr('color', 'primary')\r\n  .attr('style', 'position: absolute; z-index: 1; top: 7%;')\r\n  .attr('ng-reflect-color', 'primary')\r\n  .on('mousedown', () => {\r\n    var real_traverser = provenanceTreeVisualization.real_traverser;\r\n    var parent_id = '';\r\n    real_traverser\r\n    .filter((d: any) => {\r\n      const ref = d.data.wrappedNodes.includes(provenanceTreeVisualization.traverser.graph.current);\r\n      if(ref){\r\n        parent_id = d.parent.data.wrappedNodes[0].id;\r\n      }\r\n    });\r\n    if(provenanceTreeVisualization.groupnumber == 0)\r\n      provenanceTreeVisualization.traverser.toStateNode(parent_id, 250);\r\n    else\r\n      provenanceTreeVisualization.traverser.toStateNode(parent_id, 0);\r\n    provenanceTreeVisualization.getFullsizeview();\r\n    provenanceTreeVisualization.update();\r\n  });\r\n\r\nupwardButton\r\n  .append('span')\r\n  .attr('class', 'mat-button-wrapper')\r\n  .append('mat-icon')\r\n  .attr('class', 'mat-icon notranslate material-icons mat-icon-no-color')\r\n  .attr('role', 'img')\r\n  .attr('aria-hidden', 'true')\r\n  .text('arrow_upward');\r\n\r\nupwardButton\r\n  .append('div')\r\n  .attr('class', 'mat-button-ripple mat-ripple mat-button-ripple-round')\r\n  .attr('ng-reflect-centered', 'true')\r\n  .attr('ng-reflect-disabled', 'false')\r\n  .attr('ng-reflect-trigger', '[object HTMLButtonElement]');\r\n\r\nupwardButton\r\n  .append('div')\r\n  .attr('class', 'mat-button-focus-overlay');\r\n\r\nconst downwardButton = provenanceTreeVisualization.container\r\n  .append('button')\r\n  .attr('id', 'downward-trigger')\r\n  .attr('title', 'Move Down One Node')\r\n  .attr('class', 'mat-icon-button mat-button-base mat-primary')\r\n  .attr('color', 'primary')\r\n  .attr('style', 'position: absolute; z-index: 1; top: 12%;')\r\n  .attr('ng-reflect-color', 'primary')\r\n  .on('mousedown', () => {\r\n    var real_traverser = provenanceTreeVisualization.real_traverser;\r\n    var child_id = '';\r\n    real_traverser\r\n    .filter((d: any) => {\r\n      const ref = d.data.wrappedNodes.includes(provenanceTreeVisualization.traverser.graph.current);\r\n      if(ref){\r\n        for(const child of d.children)\r\n        {\r\n            if(child.data.wrappedNodes[0].metadata.mainbranch)\r\n                child_id = child.data.wrappedNodes[0].id;\r\n        }\r\n            \r\n      }\r\n    });\r\n    if(provenanceTreeVisualization.groupnumber == 0)\r\n      provenanceTreeVisualization.traverser.toStateNode(child_id, 250);\r\n    else\r\n      provenanceTreeVisualization.traverser.toStateNode(child_id, 0);\r\n    provenanceTreeVisualization.getFullsizeview();\r\n    provenanceTreeVisualization.update();\r\n  });\r\n\r\ndownwardButton\r\n  .append('span')\r\n  .attr('class', 'mat-button-wrapper')\r\n  .append('mat-icon')\r\n  .attr('class', 'mat-icon notranslate material-icons mat-icon-no-color')\r\n  .attr('role', 'img')\r\n  .attr('aria-hidden', 'true')\r\n  .text('arrow_downward');\r\n\r\ndownwardButton\r\n  .append('div')\r\n  .attr('class', 'mat-button-ripple mat-ripple mat-button-ripple-round')\r\n  .attr('ng-reflect-centered', 'true')\r\n  .attr('ng-reflect-disabled', 'false')\r\n  .attr('ng-reflect-trigger', '[object HTMLButtonElement]');\r\n\r\ndownwardButton\r\n  .append('div')\r\n  .attr('class', 'mat-button-focus-overlay');\r\n\r\n\r\n\r\nconst slider = provenanceTreeVisualization.container\r\n  .append('mat-slider')\r\n  .attr('id', 'group_slider')\r\n  .attr('max', provenanceTreeVisualization.numberofnodes)\r\n  .attr('min', 0)\r\n  .attr('step', 1)\r\n  .attr('thumbLabel', true)\r\n  .attr('style', 'position: absolute; z-index: 1; top: 22%;left: 10%;')\r\n  .attr('tickInterval', 5)\r\n  .attr('vertical', true)\r\n  .style('height', '300px')\r\n  .attr('matTooltip', 'Provenance-Grouping Slider');\r\n\r\nslider.append('mat-slider-thumb');\r\nslider.append('mat-slider-track-fill');\r\nslider.append('mat-slider-track-background');  \r\n\r\n\r\nconst HidecameraButton = provenanceTreeVisualization.container\r\n.append('button')\r\n.attr('id', 'camera-trigger')\r\n.attr('class', 'mat-icon-button mat-button-base mat-primary')\r\n.attr('color', 'primary')\r\n.attr('style', 'position: absolute; z-index: 1; top: 17%;')\r\n.attr('ng-reflect-color', 'primary')\r\n.attr('title', 'Hide/Show Camera Actions')\r\n.on('mousedown', () => {\r\n  if (provenanceTreeVisualization.traverser.graph.root) {\r\n    provenanceTreeVisualization.camerahide();\r\n  }\r\n});\r\n\r\nHidecameraButton\r\n  .append('span')\r\n  .attr('class', 'mat-button-wrapper')\r\n  .append('mat-icon')\r\n  .attr('class', 'mat-icon notranslate material-icons mat-icon-no-color')\r\n  .attr('role', 'img')\r\n  .attr('aria-hidden', 'true')\r\n  .text('camera_alt');\r\n\r\nHidecameraButton\r\n  .append('div')\r\n  .attr('class', 'mat-button-ripple mat-ripple mat-button-ripple-round')\r\n  .attr('ng-reflect-centered', 'true')\r\n  .attr('ng-reflect-disabled', 'false')\r\n  .attr('ng-reflect-trigger', '[object HTMLButtonElement]');\r\n\r\nHidecameraButton\r\n  .append('div')\r\n  .attr('class', 'mat-button-focus-overlay');\r\n}\r\n\r\n\r\n\r\n// /**\r\n//  * @description Slider for Arguments in simple HTML\r\n//  */\r\n// export function addSlider<T extends HTMLElement>(\r\n//   elem: d3.Selection<T, any, any, any>,\r\n//   onChange: (val: number) => any\r\n// ): void {\r\n//   const container = elem.append('div');\r\n\r\n//   container.attr('class', 'sliderContainer');\r\n//   container.attr('style', 'visibility: show');\r\n\r\n//   const slider = container\r\n//     .append('input')\r\n//     .attr('id', 'arg')\r\n//     .attr('type', 'range')\r\n//     .attr('min', 0)\r\n//     .attr('max', 10)\r\n//     .attr('value', '0')\r\n//     .attr('class', 'slider');\r\n//   const currentValue = container.append('span').text(0);\r\n\r\n//   slider.on('change', () => {\r\n//     const val = parseInt(slider.node()!.value, 10);\r\n//     currentValue.text(val);\r\n//     onChange(val);\r\n//   });\r\n// }\r\n// function showSlider(value: string) {\r\n//   const slider = d3.select('.sliderContainer');\r\n//   switch (value) {\r\n//     case 'Pruning':\r\n//     case 'PlotTrimmer':\r\n//     case 'PlotTrimmer C':\r\n//     case 'PlotTrimmer G':\r\n//       slider.attr('style', 'display:block');\r\n//       break;\r\n//     default:\r\n//       slider.attr('style', 'display: none');\r\n//   }\r\n// }\r\n","import { HierarchyNode, HierarchyPointNode } from \"d3-hierarchy\";\r\n\r\nfunction depthSort(\r\n  a: IHierarchyPointNodeWithMaxDepth<any>,\r\n  b: IHierarchyPointNodeWithMaxDepth<any>\r\n) {\r\n  if (a.maxDescendantDepth > b.maxDescendantDepth) {\r\n    return -1;\r\n  } else if (a.maxDescendantDepth < b.maxDescendantDepth) {\r\n    return 1;\r\n  }\r\n  return 0;\r\n}\r\n\r\nexport interface IGratzlLayout<Datum> {\r\n  (\r\n    root: HierarchyNode<Datum>,\r\n    activeNode: HierarchyNode<Datum>\r\n  ): IHierarchyPointNodeWithMaxDepth<Datum>;\r\n  size(): [number, number];\r\n  size(size: [number, number]): this;\r\n}\r\n\r\nexport interface IHierarchyPointNodeWithMaxDepth<Datum>\r\n  extends HierarchyPointNode<Datum> {\r\n  maxDescendantDepth: number;\r\n  xOffset: number;\r\n}\r\n\r\nexport default function GratzlLayoutOld<Datum>() {\r\n  let dx = 5;\r\n  let dy = 50;\r\n  const widths: number[] = [];\r\n\r\n  function setTreeX(node: IHierarchyPointNodeWithMaxDepth<Datum>, val: number) {\r\n    node.xOffset = val;\r\n    widths[node.depth] = val;\r\n    if (node.children) {\r\n      node\r\n        .leaves()\r\n        .sort(depthSort)\r\n        .forEach(leaf => {\r\n          if (typeof leaf.xOffset === \"undefined\") {\r\n            const width = Math.max.apply(\r\n              null,\r\n              widths.slice(node.depth, leaf.depth + 1)\r\n            );\r\n            setTreeX(leaf, val > width ? val : width + 1);\r\n          }\r\n        });\r\n    }\r\n\r\n    if (node.parent && typeof node.parent.xOffset === \"undefined\") {\r\n      setTreeX(node.parent, val);\r\n    }\r\n  }\r\n\r\n  const tree: IGratzlLayout<Datum> = Object.assign(\r\n    (_root: HierarchyNode<Datum>, _activeNode: HierarchyNode<Datum>) => {\r\n      /*\r\n       * set maxDescendantDepth on each node,\r\n       * which is the depth of its deepest child\r\n       *\r\n       * */\r\n\r\n      const root = _root as IHierarchyPointNodeWithMaxDepth<Datum>;\r\n      const activeNode = _activeNode as IHierarchyPointNodeWithMaxDepth<Datum>;\r\n\r\n      root.leaves().forEach(leaf => {\r\n        leaf.ancestors().forEach(leafAncestor => {\r\n          if (\r\n            !leafAncestor.maxDescendantDepth ||\r\n            leaf.depth > leafAncestor.maxDescendantDepth\r\n          ) {\r\n            leafAncestor.maxDescendantDepth = leaf.depth;\r\n          }\r\n        });\r\n      });\r\n\r\n      /* rendering should start at the deepest leaf of activeNode. */\r\n      let deepestLeaf = activeNode;\r\n      activeNode.leaves().forEach(leaf => {\r\n        if (deepestLeaf.depth < leaf.depth) {\r\n          deepestLeaf = leaf;\r\n        }\r\n      });\r\n\r\n      setTreeX(deepestLeaf, 0);\r\n\r\n      const maxX = Math.max.apply(null, widths);\r\n      const maxY = Math.max.apply(null, root.leaves().map(leaf => leaf.depth));\r\n      root.each(node => {\r\n        sizeNode(node, maxX, maxY);\r\n      });\r\n\r\n      return root;\r\n    },\r\n    {\r\n      size: ((x: [number, number] | undefined) => {\r\n        return x ? ((dx = +x[0]), (dy = +x[1]), tree) : [dx, dy];\r\n      }) as any\r\n    }\r\n  );\r\n\r\n  function sizeNode(\r\n    node: IHierarchyPointNodeWithMaxDepth<any>,\r\n    maxX: number,\r\n    maxY: number\r\n  ): void {\r\n    node.x = maxX === 0 ? dx : dx - (dx / maxX) * node.xOffset;\r\n    node.y = maxY === 0 ? dy : (dy / maxY) * node.depth;\r\n  }\r\n\r\n  return tree;\r\n}\r\n","import { getNodeIntent, isKeyNode } from \"./aggregation/aggregation-objects\";\r\nimport { IHierarchyPointNodeWithMaxDepth } from \"./gratzl\";\r\nimport GratzlLayoutOld from \"./gratzl_old\";\r\nimport { IGroupedTreeNode } from \"./utils\";\r\nimport { ProvenanceNode } from \"@visualstorytelling/provenance-core\";\r\nimport { HierarchyPointLink } from \"d3-hierarchy\";\r\nimport { ProvenanceTreeVisualization } from \"./provenance-tree-visualization\";\r\nimport * as d3 from \"d3\";\r\n\r\nexport function caterpillar(\r\n  updateNodes: d3.Selection<\r\n    any,\r\n    IHierarchyPointNodeWithMaxDepth<IGroupedTreeNode<ProvenanceNode>>,\r\n    any,\r\n    any\r\n  >,\r\n  treeNodes: IHierarchyPointNodeWithMaxDepth<\r\n    IGroupedTreeNode<ProvenanceNode>\r\n  >[],\r\n  updatedLinks: d3.Selection<\r\n    any,\r\n    HierarchyPointLink<IGroupedTreeNode<ProvenanceNode>>,\r\n    any,\r\n    any\r\n  >,\r\n  provenanceTreeVisualization: ProvenanceTreeVisualization\r\n) {\r\n  if (provenanceTreeVisualization.caterpillarActivated) {\r\n    const mainNodes = updateNodes.filter((d: any) => d.x === 0);\r\n    const mainNodesData = mainNodes\r\n      .data()\r\n      .map((d: any) => d.data.wrappedNodes[0].id);\r\n\r\n    // console.log(mainNodesData);\r\n\r\n    const edgeNodes = mainNodes.filter((d: any) => {\r\n      if (d.children) {\r\n        return d.children.length > 1;\r\n      }\r\n      return false;\r\n    });\r\n\r\n    edgeNodes.select(\"circle\").attr(\"class\", \"intent_wrapped\");\r\n    edgeNodes.select(\"rect\").attr(\"class\", \"intent_wrapped\");\r\n\r\n    // Hide the rest of the circles and links\r\n    updateNodes.filter((d: any) => d.x !== 0).attr(\"class\", \"node hiddenClass\");\r\n\r\n    updatedLinks\r\n      .filter((d: any) => d.target.x !== 0)\r\n      .attr(\"class\", \"node hiddenClass\");\r\n\r\n    // Set the label which indicate the number of nodes wrapped\r\n    updateNodes\r\n      .select(\"text.circle-text\")\r\n      .filter((d: any) => d.x !== 0)\r\n      .attr(\"visibility\", \"visible\");\r\n\r\n    edgeNodes\r\n      .select(\".normal>text.circle-text\")\r\n      .attr(\"visibility\", \"visible\")\r\n      .text((d: any) => {\r\n        const copyNode = d.copy();\r\n        copyNode.children = copyNode.children.filter(\r\n          (e: any, i: any, arr: any) =>\r\n            !mainNodesData.includes(e.data.wrappedNodes[0].id)\r\n        );\r\n        return copyNode.descendants().length;\r\n      })\r\n      .attr(\"x\", (d: any) => {\r\n        const copyNode = d.copy();\r\n        copyNode.children = copyNode.children.filter(\r\n          (e: any, i: any, arr: any) =>\r\n            !mainNodesData.includes(e.data.wrappedNodes[0].id)\r\n        );\r\n        if (copyNode.descendants().length < 10) {\r\n          return -1.5;\r\n        } else {\r\n          return -3;\r\n        }\r\n      });\r\n\r\n    // Set the radius of the circle\r\n    edgeNodes.select(\"circle\").attr(\"r\", (d: any) => {\r\n      return Math.min(4 + 0.15 * d.descendants().length, 6);\r\n    });\r\n\r\n    // Set the click function\r\n    edgeNodes.on(\"click\", (d: any) => {\r\n      const actualCatGraph = d3.selectAll(\".classCat\");\r\n\r\n      // When click again -> auxiliar tree disappearss.\r\n      if (\r\n        actualCatGraph\r\n          .data()\r\n          .map((k: any) => k.data.wrappedNodes[0].id)\r\n          .includes(d.data.wrappedNodes[0].id)\r\n      ) {\r\n        actualCatGraph\r\n          .data([])\r\n          .exit()\r\n          .remove();\r\n        d3.selectAll(\"path.linkCat\")\r\n          .data([])\r\n          .exit()\r\n          .remove();\r\n        // console.log(\r\n        //   actualCatGraph.data().map((k: any) => k.data.wrappedNodes[0].id)\r\n        // );\r\n        // console.log(d.data.wrappedNodes[0].id);\r\n      } else {\r\n        // else -> deploy the new tree.\r\n        const treeCopy = d.copy();\r\n        treeCopy.children = treeCopy.children.filter(\r\n          (e: any, i: any, arr: any) =>\r\n            !mainNodesData.includes(e.data.wrappedNodes[0].id)\r\n        );\r\n        const treeLayoutCat = GratzlLayoutOld<\r\n          IGroupedTreeNode<ProvenanceNode>\r\n        >().size([35, 120]);\r\n        const treeCat = treeLayoutCat(treeCopy, treeCopy);\r\n\r\n        const excatNodes = provenanceTreeVisualization.g\r\n          .selectAll(\"g.classCat\")\r\n          .data(treeCat.descendants(), (datum: any) =>\r\n            datum.data.wrappedNodes.map((n: any) => n.id).join()\r\n          );\r\n        excatNodes.exit().remove();\r\n\r\n        const catNodes = excatNodes\r\n          .enter()\r\n          .append(\"g\")\r\n          .attr(\"class\", \"classCat node branch-active \")\r\n          .data(treeNodes)\r\n          .attr(\"transform\", (datum: any) =>\r\n            datum.data.wrappedNodes[0].metadata.isSlideAdded\r\n              ? `translate(${d.x - 3}, ${d.y})`\r\n              : `translate(${d.x}, ${d.y})`\r\n          );\r\n        // .append('g')\r\n        // .attr('class', 'classCat node branch-active ')\r\n        // .attr('transform', (k: any) => `translate(${k.x}, ${k.y})`);\r\n\r\n        catNodes.append(\"circle\").attr(\"r\", 3);\r\n\r\n        // Fix the radius of the circles according to #nodes wrapped\r\n        catNodes.select(\"circle\").attr(\"r\", (datum: any) => {\r\n          let radius = 2;\r\n          if (datum.data.neighbour === true) {\r\n            radius = 3;\r\n          }\r\n          if (datum.data.wrappedNodes.length !== 1) {\r\n            radius = Math.min(4 + 0.15 * datum.data.wrappedNodes.length, 6);\r\n          }\r\n          return radius;\r\n        });\r\n\r\n        // Assign classes to the circles\r\n        catNodes.select(\"circle\").attr(\"class\", (datum: any) => {\r\n          let classString = \"\";\r\n          console.log(d.data.wrappedNodes[0].metadata);\r\n          if (d.data.wrappedNodes[0].metadata.bookmarked === true) {\r\n            classString += ' bookmarked';\r\n          }\r\n          if (isKeyNode(datum.data.wrappedNodes[0])) {\r\n            classString += \" keynode\";\r\n          }\r\n          classString += \" intent_\" + getNodeIntent(d.data.wrappedNodes[0]);\r\n\r\n          return classString;\r\n        });\r\n\r\n        catNodes.on(\"click\", datum =>\r\n          provenanceTreeVisualization.traverser.toStateNode(\r\n            datum.data.wrappedNodes[0].id,\r\n            250\r\n          )\r\n        );\r\n\r\n        // Set the #nodes-wrapped label\r\n        catNodes\r\n          .append(\"text\")\r\n          .attr(\"class\", \"circle-text\")\r\n          .attr(\"visibility\", (datum: any) => {\r\n            if (datum.data.wrappedNodes.length === 1) {\r\n              return \"hidden\";\r\n            } else {\r\n              return \"visible\";\r\n            }\r\n          })\r\n          .attr(\"x\", (datum: any) => {\r\n            if (datum.data.wrappedNodes.length >= 10) {\r\n              return -3;\r\n            }\r\n            return -1.5;\r\n          })\r\n          .attr(\"y\", 2)\r\n          .text((datum: any) => datum.data.wrappedNodes.length.toString());\r\n\r\n        // Set the links between circles\r\n        const oldLinksCat = provenanceTreeVisualization.g\r\n          .selectAll(\"path.linkCat\")\r\n          .data(treeCat.links(), (datum: any) =>\r\n            datum.target.data.wrappedNodes.map((n: any) => n.id).join()\r\n          );\r\n\r\n        oldLinksCat.exit().remove();\r\n\r\n        const newLinksCat = oldLinksCat\r\n          .enter()\r\n          .insert(\"path\", \"g\")\r\n          .attr(\"d\", provenanceTreeVisualization.linkPath as any);\r\n        oldLinksCat\r\n          .merge(newLinksCat as any)\r\n          .attr(\"class\", \"link linkCat\")\r\n          .filter((datum: any) => datum.target.x === 0)\r\n          .attr(\"class\", \"link active linkCat\");\r\n      } // end else actualgraph\r\n    }); // end on click\r\n  } // if of caterpillar procedure\r\n}\r\n","import * as d3 from 'd3';\r\nimport { HierarchyPointNode } from 'd3';\r\nimport { ProvenanceGraphTraverser, ProvenanceNode } from '@visualstorytelling/provenance-core';\r\n\r\nimport gratzl from './gratzl';\r\nimport { provGraphControls } from './controls';\r\nimport { IHierarchyPointNodeWithMaxDepth } from './gratzl';\r\nimport { IGroupedTreeNode,cam_test } from './utils';\r\nimport { NodeAggregator, transferToParent, transferChildren, transferChildren_2 } from './aggregation/aggregation-implementations';\r\n\r\nimport {\r\n  getNodeIntent,\r\n  getNodeRenderer,\r\n  groupNodeLabel,\r\n  isKeyNode,\r\n  rawData,\r\n  wrapNode,\r\n  plotTrimmerC,\r\n  plotTrimmerG\r\n} from './aggregation/aggregation-objects';\r\nimport { addAggregationButtons } from './components';\r\nimport { findHierarchyNodeFromProvenanceNode } from './aggregation/aggregation';\r\nimport { caterpillar } from './caterpillar';\r\n\r\nvar xScale = -20;\r\nvar yScale = 20;\r\nvar treeWidth = 0;\r\nvar maxtreeWidth = 10;\r\nvar p = 3;\r\nconst fontSize = 8;\r\n\r\nexport type D3SVGSelection = d3.Selection<SVGSVGElement, any, null, undefined>;\r\nexport type D3SVGGSelection = d3.Selection<SVGGElement, any, null, undefined>;\r\n\r\ndeclare const event: any;\r\n\r\nexport interface IAggregation {\r\n  aggregator: NodeAggregator<ProvenanceNode>;\r\n  arg: any;\r\n}\r\n\r\n/**\r\n * @description Class used to create and manage a provenance tree visualization.\r\n * @param traverser {ProvenanceGraphTraverser} - To manage the data structure of the graph.\r\n * @param svg {D3SVGSelection} - To manage the graphics of the tree.\r\n * @param _dataAggregation {aggregator<ProvenanceNode>} - Data aggregation in use.\r\n * @param caterpillarActivated {boolean} - True if this feature is enable.\r\n */\r\nexport class ProvenanceTreeVisualization {\r\n  public traverser: ProvenanceGraphTraverser;\r\n  public camera_show: boolean = true;\r\n  public colorScheme: any;\r\n  public numberofnodes: number = 1;\r\n  public numberOfUniqueValues: number = 1;\r\n  public groupnumber: number = 0;\r\n  public real_traverser: any;\r\n  public g: D3SVGGSelection;\r\n  public svg: D3SVGSelection;\r\n  public container: any;\r\n  public aggregation: IAggregation = {\r\n    aggregator: rawData,\r\n    arg: 1\r\n  };\r\n  public caterpillarActivated = false;\r\n  public alt = true;\r\n\r\n\r\n  private hierarchyRoot:\r\n    | IHierarchyPointNodeWithMaxDepth<IGroupedTreeNode<ProvenanceNode>>\r\n    | undefined;\r\n\r\n  private zoomer: any;\r\n  private currentHierarchyNodelength: any = 0;\r\n  private currentHierarchyMaxlength: any = 0;\r\n  private keynode: any;\r\n  \r\n  private TreeLength: any = 0;\r\n  private TreeWidth: any = 0.1;\r\n\r\n  private sizeX: any = window.innerWidth;\r\n  private sizeY: any = window.innerHeight;\r\n\r\n  public mergingEnabled: boolean = false;\r\n  public transferringEnabled: boolean = false;\r\n  public copyingEnabled: boolean = false;\r\n\r\n  constructor(traverser: ProvenanceGraphTraverser, elm: HTMLDivElement) {\r\n    this.traverser = traverser;\r\n    this.colorScheme = d3.scaleOrdinal(d3.schemeAccent);\r\n    this.container = d3.select(elm)\r\n      .append('div')\r\n      .attr('class', 'visualizationContainer')\r\n      .attr('style', 'width: 100%; height:' + `${window.innerHeight}` + 'px');\r\n\r\n    provGraphControls(this);\r\n\r\n    // Append svg element\r\n    this.svg = this.container\r\n      .append('div')\r\n      .append('svg')\r\n      .attr(\r\n        'style',\r\n        `overflow: visible; width: 100%; height: 100%; font-size: ${fontSize}px; line-height: ${fontSize}px`\r\n      );\r\n\r\n    this.g = this.svg.append('g');\r\n\r\n    // Append grouping buttons\r\n    addAggregationButtons(this.container, this);\r\n\r\n    // Disable dbclick zoom\r\n    this.svg.on('dblclick.zoom', null);\r\n\r\n    traverser.graph.on('currentChanged', () => {\r\n      this.update();\r\n      (window as any).slideDeckViz.onChange(traverser.graph.current);\r\n      (window as any).slideDeckViz.provchanged(traverser.graph.current);\r\n\r\n\r\n    });\r\n\r\n    traverser.graph.on('nodeChanged', () => {\r\n      this.update();\r\n    });\r\n\r\n    traverser.graph.on('nodeAdded', () => {\r\n      this.currentHierarchyNodelength += 1.0;\r\n      this.scaleToFit();\r\n      this.numberofnodes++;\r\n    });\r\n\r\n    this.update();\r\n    this.zoomer = d3.zoom() as any;\r\n    this.setZoomExtent();\r\n    this.svg.call(this.zoomer);\r\n  }\r\n  public setZoomExtent() {\r\n    this.zoomer.scaleExtent([0.1, 10]).on('zoom', () => {\r\n      this.g.attr('transform', (d3 as any).event.transform);\r\n    });\r\n    this.scaleToFit();\r\n  }\r\n\r\n  public scaleToFit() {\r\n\r\n\r\n    const maxScale = 3;\r\n    const magicNum = 0.75; // todo: get relevant number based on dimensions\r\n    this.sizeX = window.innerWidth * 0.2;\r\n    this.sizeY = window.innerHeight;\r\n    const margin = 0;\r\n    const node_length = (this.currentHierarchyNodelength) * yScale * maxScale;\r\n    const node_width = (this.TreeWidth) * xScale * maxScale;\r\n    const node_max = Math.floor(this.sizeY / (yScale * maxScale));\r\n    const trans_y = (node_length > this.sizeY)? (this.currentHierarchyNodelength - node_max + margin) * yScale * maxScale: -20;\r\n\r\n\r\n    const scaleFactor = Math.min(\r\n      maxScale,\r\n      (magicNum * this.sizeY) / (this.currentHierarchyNodelength * yScale),\r\n      (magicNum * this.sizeX) / (this.TreeWidth * -xScale)\r\n    );\r\n\r\n    this.svg\r\n      .transition()\r\n      .duration(0)\r\n      .call(this.zoomer.transform, () =>\r\n        d3.zoomIdentity.translate(this.sizeX / 2.1, -trans_y).scale(maxScale)\r\n      );\r\n  }\r\n\r\n  public linkPath({\r\n    source,\r\n    target\r\n  }: {\r\n    source: HierarchyPointNode<IGroupedTreeNode<ProvenanceNode>>;\r\n    target: HierarchyPointNode<IGroupedTreeNode<ProvenanceNode>>;\r\n  }): string {\r\n    const [s, t] = [source, target];\r\n\r\n    // tslint:disable-next-line\r\n    return `M${s.x * xScale},${s.y * yScale}\r\n              C${s.x * xScale},  ${(s.y * yScale + t.y * yScale) / 2} ${t.x *\r\n      xScale},  ${(s.y * yScale + t.y * yScale) / 2} ${t.x * xScale},  ${t.y *\r\n      yScale}`;\r\n  }\r\n  /**\r\n   * @descriptionWrap text labels\r\n   */\r\n  public wrap(text: any, width: any) {\r\n    text.each(function () {\r\n      const words = text\r\n        .text()\r\n        .split(/(?=[A-Z])/)\r\n        .reverse();\r\n      let word,\r\n        line = [],\r\n        lineNumber = 0;\r\n      const lineHeight = 1.0, // ems\r\n        y = text.attr('y'),\r\n        dy = 0;\r\n      let tspan = text\r\n        .text(null)\r\n        .append('tspan')\r\n        .attr('x', 7)\r\n        .attr('y', y)\r\n        .attr('dy', dy + 'em');\r\n      while ((word = words.pop())) {\r\n        line.push(word);\r\n        tspan.text(line.join(' '));\r\n        if (tspan.node().getComputedTextLength() > width) {\r\n          line.pop();\r\n          tspan.text(line.join(' '));\r\n          line = [word];\r\n          tspan = text\r\n            .append('tspan')\r\n            .attr('x', 7)\r\n            .attr('y', y)\r\n            .attr('dy', ++lineNumber * lineHeight + dy + 'em')\r\n            .text(word);\r\n        }\r\n      }\r\n    });\r\n  }\r\n\r\n  public camerahide(): void {\r\n    function find_noncameranode(c_trav : any) {\r\n      let traverser = c_trav.graph.current;\r\n      if(traverser.label === \"root\")\r\n        return traverser;\r\n      do{        \r\n        const searchpattern = cam_test(traverser.label);\r\n        if(!searchpattern)\r\n          return traverser;\r\n        traverser = traverser.parent;\r\n        } while(traverser.label !== \"root\");\r\n      return traverser;\r\n    }\r\n    this.camera_show = this.camera_show ? false : true;\r\n    if(!this.camera_show){\r\n      const closenode = find_noncameranode(this.traverser);\r\n      this.traverser.toStateNode(closenode.id, 0);\r\n    }\r\n    this.update();\r\n    this.getFullsizeview();\r\n  }\r\n\r\n  public getFullsizeview(): void {\r\n    this.sizeX = window.innerWidth * 0.2;\r\n    this.sizeY = window.innerHeight;\r\n    const maxScale = 3;\r\n    const margin = 0;\r\n    const node_length = (this.currentHierarchyMaxlength + 1 + margin) * yScale * maxScale;\r\n    const node_max = this.sizeY / node_length;\r\n    //Need to Modify\r\n    const tx = (this.TreeWidth >= 4) ? (this.sizeX / 1.8) : (this.sizeX / 2);\r\n    const scaleFactor = Math.min(\r\n      maxScale,\r\n      maxScale * node_max,\r\n      maxScale * this.sizeX / (this.TreeWidth * -xScale * 2.1 * maxScale)\r\n    ); // find the smallest scale(Length, Width, )\r\n    this.svg\r\n    .transition()\r\n    .duration(0)\r\n    .call(this.zoomer.transform, () =>\r\n      d3.zoomIdentity.translate(tx, 20).scale(scaleFactor) // fix size\r\n    );\r\n  }\r\n\r\n\r\n  public setTraverser(traverser: ProvenanceGraphTraverser): void {\r\n    this.traverser = traverser;\r\n  }\r\n\r\n  public removeNodesAndLinkChildren<T>(tree: IGroupedTreeNode<T>, condition: (node: IGroupedTreeNode<T>) => boolean): IGroupedTreeNode<T> {\r\n    const removeNodes = (node: IGroupedTreeNode<T>) => {\r\n      for (let i = 0; i < node.children.length; i++) {\r\n        const child = node.children[i];\r\n  \r\n        if (condition(child)) {\r\n          // Remove the node from the children array\r\n          node.children.splice(i, 1);\r\n  \r\n          // Append the children of the removed node to the parent\r\n          node.children.push(...child.children);\r\n  \r\n          // Decrement the index to recheck the same position after the update\r\n          i--;\r\n        } else {\r\n          // Recursively call removeNodes for the child\r\n          removeNodes(child);\r\n        }\r\n      }\r\n    };\r\n  \r\n    // Create a shallow copy of the tree\r\n  \r\n    // Call the removeNodes function on the copied tree\r\n    removeNodes(tree);\r\n  \r\n    return tree;\r\n  }\r\n  public Grouping_hierarchy<T>(wraproot: IGroupedTreeNode<ProvenanceNode>): d3.HierarchyNode<IGroupedTreeNode<ProvenanceNode>> {\r\n    let hierarchyRoot = d3.hierarchy(wraproot);\r\n    let allnodes = hierarchyRoot.descendants().filter((d: any) => d.data.wrappedNodes[0].label !== 'Root');\r\n    let branches = allnodes.filter((d:any) => d.data.children.length > 1).length;\r\n    let bookmarks = allnodes.filter((d:any) => d.data.wrappedNodes[0].metadata.bookmarked).length;\r\n    allnodes = allnodes.filter((d:any) => d.parent.data.children.length == 1); // exclude branches merging\r\n    allnodes.sort((a, b) => {\r\n      return a.data.wrappedNodes[0].metadata.H_value - b.data.wrappedNodes[0].metadata.H_value;\r\n    });\r\n    \r\n    console.log('======Before======')\r\n    console.log(allnodes.map(node => node.depth));\r\n    console.log(allnodes.map(node => node.data.wrappedNodes[0].metadata.H_value));\r\n    console.log(allnodes.map(node => node.data.wrappedNodes[0].metadata.O_group));\r\n\r\n    //size-calculation (    )\r\n    const uniqueValues = allnodes.map(node => node.data.wrappedNodes[0].metadata.O_group);\r\n    var outputArr = uniqueValues.filter((value, index, self) => {\r\n      return self.indexOf(value) === index;\r\n    });\r\n    this.numberOfUniqueValues = outputArr.length + branches + bookmarks;\r\n\r\n\r\n    const groupslicenodes = allnodes.slice(0, this.groupnumber);\r\n    groupslicenodes.sort((a, b) => {return b.depth - a.depth});\r\n    groupslicenodes.sort((a, b) => {return a.data.wrappedNodes[0].metadata.branchnumber - b.data.wrappedNodes[0].metadata.branchnumber})\r\n    let Endnode = 0;\r\n    let Startnode = 0;\r\n    for(let i = 0; i<groupslicenodes.length; i++){\r\n      if(groupslicenodes[i].depth - groupslicenodes[i+1]?.depth == 1){\r\n        Startnode = i;\r\n        Endnode = i+1;\r\n        for(Endnode; Endnode<groupslicenodes.length; Endnode++){\r\n          if(groupslicenodes[Endnode].depth - groupslicenodes[Endnode+1]?.depth != 1){\r\n            break;\r\n          }\r\n        }\r\n        transferChildren_2(groupslicenodes[Endnode].parent, groupslicenodes[Endnode],groupslicenodes[Startnode]);\r\n        i = Endnode;\r\n      }\r\n      else{\r\n        transferChildren(groupslicenodes[i].parent!.parent!.data as any, groupslicenodes[i].parent!.data as any, groupslicenodes[i].data as any);\r\n      }\r\n\r\n    }\r\n    // groupslicenodes.forEach((node) => transferChildren(node.parent!.parent!.data as any, node.parent!.data as any, node.data as any));\r\n    // for(let i = 0; i < this.groupnumber; i++){\r\n    \r\n    //   if (allnodes.length >= i && allnodes[i]?.parent?.data && allnodes[i].data) {\r\n    //     transferChildren(allnodes[i].parent!.parent!.data, allnodes[i].parent!.data, allnodes[i].data);\r\n    //   }\r\n    //  }\r\n\r\n    hierarchyRoot = d3.hierarchy(wraproot); // Updated the treeRoot\r\n    allnodes = hierarchyRoot.descendants().filter((d: any) => d.data.wrappedNodes[0].label !== 'Root');\r\n    allnodes.sort((a, b) => {\r\n      return a.data.wrappedNodes[0].metadata.H_value - b.data.wrappedNodes[0].metadata.H_value;\r\n    });\r\n    console.log('======After======')\r\n    console.log(groupslicenodes);\r\n    console.log(allnodes.map(node => node.depth));\r\n    console.log(allnodes.map(node => node.data.wrappedNodes[0].metadata.H_value));\r\n    console.log(allnodes.map(node => node.data.wrappedNodes[0].metadata.O_group));\r\n\r\n    return hierarchyRoot;\r\n  }\r\n  /**\r\n   * @description Update the tree layout.\r\n   */\r\n  public update = ()  =>  {\r\n    let wrappedRoot = wrapNode(this.traverser.graph.root);\r\n    let clonedWrappedRoot = wrapNode(this.traverser.graph.root);\r\n    let camhideNodes = this.removeNodesAndLinkChildren(clonedWrappedRoot, node => node.camera === true); \r\n\r\n    let hierarchyRoot;\r\n    // aggregateNodes(this.aggregation, wrappedRoot, this.traverser.graph.current);\r\n    if (this.camera_show == true)\r\n      // hierarchyRoot = d3.hierarchy(wrappedRoot); // Updated the treeRoot\r\n      hierarchyRoot = this.Grouping_hierarchy(wrappedRoot);\r\n    else{\r\n      hierarchyRoot = d3.hierarchy(camhideNodes);\r\n      if(cam_test(this.traverser.graph.current.label)){\r\n        this.currentHierarchyNodelength = hierarchyRoot.path(this.keynode\r\n          ).length;\r\n        this.scaleToFit();\r\n        return ;\r\n      }\r\n    }\r\n    let currentHierarchyNode;\r\n    hierarchyRoot.each(node => {\r\n      if (node.data.wrappedNodes.includes(this.traverser.graph.current)) {\r\n        currentHierarchyNode = node;\r\n      }\r\n    });\r\n    if (currentHierarchyNode === undefined) {\r\n      this.traverser.toStateNode((this.traverser.graph.current as any).parent.id);\r\n      return;\r\n    }\r\n    this.currentHierarchyNodelength = hierarchyRoot.path(currentHierarchyNode as d3.HierarchyNode<IGroupedTreeNode<ProvenanceNode>>).length;\r\n    const tree = gratzl(hierarchyRoot, currentHierarchyNode as d3.HierarchyNode<IGroupedTreeNode<ProvenanceNode>>);\r\n    this.hierarchyRoot = tree;\r\n    const treeNodes = tree.descendants().filter((d: any) => d.data.wrappedNodes[0].metadata.option !== 'merged');\r\n    const treemaxwidth = tree.descendants().map(function (item) {return item.x}).reduce(function(prev, current) {return (prev > current) ? prev : current});\r\n    const treemaxlength = tree.descendants().map(function (item) {return item.y}).reduce(function(prev, current) {return (prev > current) ? prev : current});\r\n    this.currentHierarchyMaxlength = treemaxlength;\r\n    const oldNodes = this.g.selectAll('g.node').data(treeNodes, (d: any) => {\r\n      const data = d.data.wrappedNodes.map((n: any) => n.id).join();\r\n      return data;\r\n    });\r\n    // console.log(treemaxwidth);\r\n    this.TreeWidth = Math.max(this.TreeWidth,treemaxwidth);\r\n    this.TreeLength = Math.max(this.TreeLength,treemaxlength);\r\n    oldNodes.exit().remove();\r\n    // group wrapping a node\r\n    const newNodes = oldNodes\r\n      .enter()\r\n      .append('g')\r\n      .attr('class', 'node')\r\n      .attr(\r\n        'transform',\r\n        (d: any) => `translate(${d.x * xScale}, ${d.y * yScale})`\r\n      );\r\n\r\n    // node label\r\n    newNodes\r\n    .append('foreignObject')\r\n    .attr('class', 'circle-img')\r\n    .attr('width', 15)\r\n    .attr('height', 15)\r\n    .attr('x', 7)\r\n    .attr('y', -17)\r\n    .html(d => {\r\n      if (d.data.wrappedNodes[0].metadata.screenshot) {\r\n        return `<div><img src=\"${d.data.wrappedNodes[0].metadata.screenshot}\" width=\"15\" height=\"15\" /></div>`;\r\n      } else {\r\n        return '';\r\n      }\r\n    })\r\n    \r\n  \r\n  newNodes\r\n    .append('text')\r\n    .attr('class', 'circle-label')\r\n    .text(d => groupNodeLabel(d.data)) // .text(d => d.data.neighbour.toString())\r\n    .attr('x', 7)\r\n    .attr('alignment-baseline', 'central');\r\n\r\n  // newNodes\r\n  //   .append('text')\r\n  //   .attr('class', 'depth-label')\r\n  //   .text(d => (d.data.wrappedNodes.length > 1)?d.data.wrappedNodes.length:'') // .text(d => d.data.neighbour.toString())\r\n  //   .attr('x', 0)\r\n  //   .attr('alignment-baseline', 'central');\r\n\r\n    // .call(this.wrap, 70);\r\n    const updateNodes = newNodes.merge(oldNodes as any);\r\n\r\n    updateNodes.selectAll('g.normal').remove();\r\n    updateNodes.selectAll('g.bookmarked').remove();\r\n    updateNodes.selectAll('.circle-text').remove();\r\n\r\n    const getNodeSize = (node: any) => {\r\n      let counter = 0;\r\n      const countWrappedNodesRecursively = (currentNode: ProvenanceNode[]) => {\r\n        counter += currentNode.length;\r\n        currentNode.forEach((nodes: any) => {\r\n            if (nodes.wrappedNodes) {\r\n              countWrappedNodesRecursively(nodes.wrappedNodes as any);\r\n            }\r\n          });\r\n      };\r\n    \r\n      countWrappedNodesRecursively(node.wrappedNodes);      \r\n      \r\n      return Math.min(2.7 + 0.6 * node.wrappedNodes.length, 7);\r\n    };\r\n\r\n    // other nodes to circle\r\n    updateNodes\r\n      .filter((d: any) => {\r\n        return !d.data.wrappedNodes.some(\r\n          (node: ProvenanceNode) => node.metadata.isSlideAdded\r\n        );\r\n      })\r\n      .append('g')\r\n      .attr('class', 'normal');\r\n\r\n\r\n    updateNodes.on('contextmenu', (d: any) => {\r\n      this.traverser.toStateNode(d.data.wrappedNodes[0].id, 0);\r\n      this.traverser.graph.current = this.traverser.graph.getNode(d.data.wrappedNodes[0].id);\r\n      // this.update();\r\n      // (window as any).slideDeckViz.onChange();\r\n      d.data.wrappedNodes[0].metadata.bookmarked = !d.data.wrappedNodes[0].metadata.bookmarked;\r\n      if (!d.data.wrappedNodes[0].metadata.bookmarked) {\r\n        (window as any).slideDeckViz.onDelete(null, this.traverser.graph.current);\r\n        this.traverser.graph.current.metadata.H_value-=50000;\r\n      } else {\r\n        (window as any).slideDeckViz.onAdd(this.traverser.graph.current);\r\n        this.traverser.graph.current.metadata.H_value+=50000;\r\n      }\r\n      this.update();\r\n    });\r\n\r\n    updateNodes.on('dblclick', (d: any) => {\r\n      this.traverser.toStateNode(d.data.wrappedNodes[0].id, 0);\r\n      this.traverser.graph.current = this.traverser.graph.getNode(d.data.wrappedNodes[0].id);\r\n      // collapse the nodes as it is\r\n      // if((this.traverser.graph.current as any).parent.){\r\n      //   this.traverser.graph.current = this.traverser.graph.current.children[0];\r\n      // }\r\n      console.log('hello');\r\n      this.update();\r\n      // d.data.\r\n    });\r\n\r\n\r\n    // set classes on node\r\n    updateNodes\r\n        .attr('class', 'node')\r\n        .filter((d: any) => {\r\n        if (d.x === 0) {\r\n          d.data.wrappedNodes[0].metadata.mainbranch = true;\r\n        }\r\n        else {\r\n          d.data.wrappedNodes[0].metadata.mainbranch = false;\r\n        }\r\n        return d.x === 0; \r\n      })\r\n      .attr('class', 'node branch-active')\r\n      .filter((d: any) => {\r\n        let neighbourNode: boolean = false;\r\n        if ((this.traverser.graph.current as any).parent) { //    \r\n          neighbourNode = (this.traverser.graph.current as any).parent === d.data.wrappedNodes[0] ? true : neighbourNode; //      \r\n          d.data.wrappedNodes[0].metadata.neighbour = neighbourNode ? true : neighbourNode;\r\n        }  \r\n        if ((this.traverser.graph.current as any).children.length !== 0) {\r\n          for (const child of (this.traverser.graph.current as any).children){\r\n            neighbourNode = d.data.wrappedNodes.includes(child) ? true : neighbourNode;\r\n            d.data.wrappedNodes[0].metadata.neighbour = neighbourNode ? true : neighbourNode;\r\n          }\r\n        }\r\n        return neighbourNode;\r\n      })      \r\n      .attr('class', 'node branch-active neighbour');\r\n\r\n\r\n      updateNodes\r\n      .filter((d: any) => {\r\n        const ref = d.data.wrappedNodes.includes(this.traverser.graph.current);\r\n        return ref;\r\n      })\r\n      .attr('class', 'node branch-active neighbour node-active');\r\n\r\n\r\n    updateNodes\r\n      .select('g')\r\n      .append((d: any) => {\r\n        const isBookmarked = d.data.wrappedNodes.some((node: any) => {\r\n          return node.metadata.bookmarked === true;\r\n        });\r\n        // Check if the node is bookmarked\r\n        if (isBookmarked) {\r\n          // If yes, create a square shape\r\n          return document.createElementNS(d3.namespaces.svg, 'rect');\r\n        } else {\r\n          // Otherwise, create a circle shape\r\n          return document.createElementNS(d3.namespaces.svg, 'circle');\r\n        }\r\n      })\r\n      .on('dblclick.zoom', null)\r\n      .attr('class', (d: any) => {\r\n        let classString = '';\r\n        const isBookmarked = d.data.wrappedNodes.some((node: any) => {\r\n          return node.metadata.bookmarked === true;\r\n        });\r\n        if (isBookmarked) {\r\n          classString += ' bookmarked';\r\n        } else if (d.data.wrappedNodes[0].metadata.loaded === true) {\r\n          classString += ' loaded';\r\n        }\r\n        if (isKeyNode(d.data.wrappedNodes[0])) {\r\n          classString += ' keynode';\r\n          this.keynode = d;\r\n        }\r\n        classString += ' intent_' + getNodeIntent(d.data.wrappedNodes[0]);\r\n        return classString;\r\n      })\r\n      .attr('r', (d: any) => {\r\n        let nodeSize: number = getNodeSize(d.data);\r\n        if (d.data.wrappedNodes[0].metadata.neighbour === true) {\r\n          nodeSize = getNodeSize(d.data) * 1;\r\n        }\r\n        if (d.data.wrappedNodes.includes(this.traverser.graph.current)) {\r\n          nodeSize = getNodeSize(d.data) * 1;\r\n        }\r\n        return nodeSize;\r\n      })\r\n      .attr('width', (d: any) => {\r\n        // Set square width based on node size if bookmarked\r\n        return getNodeSize(d.data) * 2;\r\n      })\r\n      .attr('height', (d: any) => {\r\n        // Set square height based on node size if bookmarked\r\n        return getNodeSize(d.data) * 2;\r\n      })\r\n      .attr('x', (d: any) => {\r\n        // Position square based on node size if bookmarked\r\n        const isBookmarked = d.data.wrappedNodes.some((node: any) => {\r\n          return node.metadata.bookmarked === true;\r\n        });\r\n        if (isBookmarked) {\r\n          return -getNodeSize(d.data);\r\n        }\r\n        else\r\n          return 7\r\n\r\n      })\r\n      .attr('y', (d: any) => {\r\n        // Position square based on node size if bookmarked\r\n        const isBookmarked = d.data.wrappedNodes.some((node: any) => {\r\n          return node.metadata.bookmarked === true;\r\n        });\r\n        if (isBookmarked) {\r\n          return -getNodeSize(d.data);\r\n        }\r\n        else\r\n          return -17\r\n      });\r\n    // hide labels not in branch\r\n    updateNodes\r\n      .select('text.circle-label')\r\n      .attr('class', (d: any) => 'circle-label renderer_' + getNodeRenderer(d.data.wrappedNodes[0]))\r\n      .attr('visibility', (d: any) => (d.x === 0 ? 'visible' : 'hidden'));\r\n\r\n    updateNodes\r\n      .select('foreignObject.circle-img')\r\n      .attr('class', (d: any) => 'circle-img renderer_' + getNodeRenderer(d.data.wrappedNodes[0]))\r\n      .attr('visibility', (d: any) => (d.x === 0 ? 'visible' : 'hidden'));\r\n    \r\n    updateNodes.on('click', d => {\r\n      \r\n      if(d.data.wrappedNodes[0].id !== this.traverser.graph.current.id){\r\n        this.traverser.toStateNode(d.data.wrappedNodes[0].id, 0); // set to 0 to all trans related works\r\n      }\r\n    });\r\n\r\n    updateNodes\r\n    .append('text')\r\n    .attr('class', 'depth-label')\r\n    .text(d => (d.data.wrappedNodes.length > 1)?d.data.wrappedNodes.length:'') // .text(d => d.data.neighbour.toString())\r\n    .attr('x', -1)\r\n    .attr('alignment-baseline', 'central');\r\n\r\n\r\n    updateNodes\r\n      .data(treeNodes)\r\n      .transition()\r\n      .duration(500)\r\n      .attr(\r\n        'transform',\r\n        (d: any) => {\r\n          if (d.x > treeWidth && treeWidth <= maxtreeWidth) {\r\n            var classString = `translate(${d.x * xScale}, ${d.y * yScale})`;\r\n            treeWidth = d.x;\r\n            if (treeWidth % p) {\r\n            }\r\n          } else {\r\n            var classString = `translate(${d.x * xScale}, ${d.y * yScale})`;\r\n          }\r\n          return classString;\r\n        }\r\n      );\r\n\r\n    const oldLinks = this.g\r\n      .selectAll('path.link')\r\n      .data(tree.links()\r\n        .filter((d: any) => d.target.data.wrappedNodes[0].metadata.option !== 'merged'),\r\n        (d: any) => d.target.data.wrappedNodes.map((n: any) => n.id).join()\r\n      );\r\n\r\n    oldLinks.exit().remove();\r\n\r\n    const newLinks = oldLinks\r\n      .enter()\r\n      .insert('path', 'g')\r\n      .attr('d', (d: any) => this.linkPath(d));\r\n\r\n    oldLinks\r\n      .merge(newLinks as any)\r\n      .attr('class', 'link')\r\n      .filter((d: any) => d.target.x === 0)\r\n      .attr('class', 'link active');\r\n\r\n    oldLinks\r\n      .merge(newLinks as any)\r\n      .transition()\r\n      .duration(500)\r\n      .attr('d', (d: any) => this.linkPath(d));\r\n\r\n    const updatedLinks = oldLinks.merge(newLinks as any);\r\n    if (this.caterpillarActivated) {\r\n      caterpillar(updateNodes, treeNodes, updatedLinks, this);\r\n    }\r\n    this.real_traverser = updateNodes;\r\n    // this.scaleToFit();\r\n  } // end update\r\n\r\n  public getTraverser(): ProvenanceGraphTraverser {\r\n    return this.traverser;\r\n  }\r\n}"],"names":["isStateNode","d3.selectAll","d3.hierarchy","gratzl","d3.namespaces","d3.scaleOrdinal","d3.schemeAccent","d3.select","d3.zoom","d3.event","d3.zoomIdentity"],"mappings":"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"}